<html>

<head>
    <title>Chess Project</title>
    <link rel="stylesheet" href="style.css">
</head>

<style>
    body {
        margin: 0;
    }

    canvas {
        width: 100%;
        height: 100%
    }
</style>

<body>
    <script src="js/three.js"> </script>
    <script src="js/OrbitControls.js"> </script>
    <script src="js/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"
        integrity="sha512-WoO4Ih0CDOSLYafy22wZD/mcJ7k0ESLqtQsFa6zFKnEUrbtuGU+GkLtVhgt93xa2qewG5gKEC6CWlN8OaCTSVg=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="js/menu.js"> </script>

    <style>
        body {
            font-family: Monospace;
            background-color: #000;
            color: #fff;
            margin: 0px;
            overflow: hidden;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
        }
    </style>

    <div id = "menu" class = "container">

        <div class = "title-header">
            <h1> Games </h1>  
        </div>

        <div class = "play-class">
            <button id="game1" class = "game-button" onclick = "button1()" > Kasparov Vs Topalov (1999) </button>
            <button id="game2" class = "game-button" onclick = "button2()" > Morphy Vs Allies (1858) </button>
            <button id="game3" class = "game-button" onclick = "button3()"> Aronian Vs Anand (2013) </button>
            <button id="game4" class = "game-button" onclick = "button4()"> Karpov Vs Kasparov (1985) </button>
            <button id="game5" class = "game-button" onclick = "button5()"> Byrne Vs Fischer (1956) </button>
            <button id="game6" class = "game-button" onclick = "button6()"> Ivanchuk Vs Yusupov (1991) </button>
            <button id="game7" class = "game-button" onclick = "button7()"> Short Vs Tmman (1991) </button>
            <button id="game8" class = "game-button" onclick = "button8()"> BaiJinshi Vs DingLiren (2017) </button>
            <button id="game9" class = "game-button" onclick = "button9()"> Rotlewi Vs Rubinstein (1997) </button>
            <button id="game10" class = "game-button" onclick = "button10()"> Geller Vs Euwe (1953) </button>    
        </div>
    </div>
    
    <div id="TextBox"></div>

    <div class ="text-instruction">
        <p> 1. Choose a game from the list of previous matches <br>
            2. Playout the entire game played by the players by pressing or holding "Spacebar" <br>
            3. Change the preferred style of the game using controls at top right corner <br>
            4. Reset the whole game using the "reset" button
        </p>
    </div>

    <div class = "button-corner">
        <button id="reset_button" class = "reset-button" onclick= "resetBtn()"> Reset </button>
    </div>

    <script>
        
        //reload the page
        function resetBtn(){
            location.reload();
        }

        //holds the pieces of each player, whites and blacks
        var black_pieces = {};
        var white_pieces = {};
        let whiteTileColour = new THREE.Color(0xffffff);
        let blackTileColour = new THREE.Color(0x000000);
        let checkTileColour = new THREE.Color(0xd61b1b);

        const textureLoader = new THREE.TextureLoader();
        let pieceTextures = {};

        var scene, camera, renderer;
        let loader = new THREE.GLTFLoader();
        let material = new THREE.MeshPhongMaterial({ color: 0x55B663 });
        var board, game_group;

        var blackPieceMaterial = new THREE.MeshPhongMaterial({ color: new THREE.Color(0x303030) });
        var whitePieceMaterial = new THREE.MeshPhongMaterial({ color: new THREE.Color(0x8f8f8f) });


        var blackTileMaterial = new THREE.MeshStandardMaterial({
            color: new THREE.Color(0x303030),
        });


        var whiteTileMaterial = new THREE.MeshStandardMaterial({
            color: new THREE.Color(0x8f8f8f),
        });

        var model_pawn = null;
        var model_knight = null;
        var model_rook = null;
        var model_queen = null;
        var model_king = null;
        var model_bishop = null;

        /* StorePGN should write the proper pieces in the array board with the format of "BP0" for black pawn 0 */
        /* 
            B for black, W for white,
            R for rook, K for knight, B for bishop, K for king, Q for queen, P for pawn
            0 .. 7 the number of the pieces which are duplicated in each color,
            0 for the ones on the left hand, 1 for the ones on  the right hand, 
        */
        let pieceMap = [
            ["BR0", "BN0", "BB0", "BQ", "BK", "BB1", "BN1", "BR1"],
            ["BP0", "BP1", "BP2", "BP3", "BP4", "BP5", "BP6", "BP7"],
            ["", "", "", "", "", "", "", ""],
            ["", "", "", "", "", "", "", ""],
            ["", "", "", "", "", "", "", ""],
            ["", "", "", "", "", "", "", ""],
            ["WP0", "WP1", "WP2", "WP3", "WP4", "WP5", "WP6", "WP7"],
            ["WR0", "WN0", "WB0", "WQ", "WK", "WB1", "WN1", "WR1"]
        ];
        const Board = {
            tilemap: [],
        };

        board = Board;
        board.tilemap = new Array(8);
        for (let i = 0; i < 8; i++) {
            board.tilemap[i] = new Array(8);
        }

        class Tile {
            constructor(file, rank) {
                this.file = file;
                this.rank = rank;
                this.colour;
                this.piece;
                this.mesh;
                this.originalMaterial;
            }
            getColour() {
                return this.colour;
            }
            setColour(value) {
                this.colour = value;
            }
            getRank() {
                return this.rank;
            }
            getFile() {
                return this.file;
            }
            getPiece() {
                return this.piece;
            }
            setPiece(value) {
                this.piece = value;
            }
            getMesh() {
                return this.mesh;
            }
            setMesh(value) {
                this.mesh = value;
            }
            getOriginalMaterial() {
                return this.originalMaterial;
            }
            setOriginalMaterial(value) {
                this.originalMaterial = value;
            }
        }

        class Piece {
            constructor(type, tile, mesh, colour) {
                this.type = type;
                this.tile = tile;
                this.mesh = mesh;
                this.colour = colour;
            }
            getType() {
                return this.type;
            }
            getTile() {
                return this.tile;
            }
            setTile(value) {
                this.tile = value;
            }
            getColour() {
                return this.colour;
            }
            setColour(value) {
                this.colour = value;
            }
            getMesh() {
                return this.mesh;
            }
            setMesh(value) {
                this.mesh = value;
            }
            updatePosition() {
                this.mesh.position.set(FileToPos(this.tile.getFile()), 0, (RankToPos(this.tile.getRank()) * -1));
            }
        }

        class TakenPieces {
            constructor(colour) {
                this.colour = colour;
                this.pieces = [];
            }
            getPieces() {
                return this.pieces;
            }
            setPieces(value) {
                this.pieces = value;
            }
            addPiece(value) {
                this.pieces.push(value);
                if (this.colour === 'W') {
                    for (let i = 0; i < this.pieces.length; i++) {
                        switch (true) {
                            case i <= 3:
                                this.pieces[i].getMesh().position.set(8+i, 0, 0);
                                break;
                            case i <= 7:
                                this.pieces[i].getMesh().position.set(4+i, 0, -1);
                                break;
                            case i <= 11:
                                this.pieces[i].getMesh().position.set(0+i, 0, -2);
                                break;
                            default:
                                this.pieces[i].getMesh().position.set(-4+i, 0, -3);
                                break;
                        }
                    }
                }
                else {
                    for (let i = 0; i < this.pieces.length; i++) {
                        switch (true) {
                            case i <= 3:
                                this.pieces[i].getMesh().position.set(-1-i, 0, -7);
                                break;
                            case i <= 7:
                                this.pieces[i].getMesh().position.set(3-i, 0, -6);
                                break;
                            case i <= 11:
                                this.pieces[i].getMesh().position.set(7-i, 0, -5);
                                break;
                            default:
                                this.pieces[i].getMesh().position.set(11-i, 0, -4);
                                break;
                        }
                    }
                }
            }
        }

        //make the script wait until all the pieces are loaded before initializing the game and rendering
        loadModels().then(
            function () {
                init();
                animate();
            }
        );

        class ColorGUIHelper {
            constructor(object, prop) {
                this.object = object;
                this.prop = prop;
            }
            get value() {
                return `#${this.object[this.prop].getHexString()}`;
            }
            set value(hexString) {
                this.object[this.prop].set(hexString);
            }
        }

        function loadTextureSet(folder) {
            let color = textureLoader.load(`Textures/${folder}/basecolor.jpg`);
            color.wrapS = color.wrapT = THREE.RepeatWrapping;
            pieceTextures[folder] = {};
            pieceTextures[folder].color = color;
        }

        //loading skyboxes to the scene
        function addSkybox(selectSkybox)
        {
            const loader = new THREE.CubeTextureLoader();
            switch (selectSkybox){
                case "cloudy":
                    var skybox = loader.load([
                        'Skybox/Cloudy/bluecloud_bk.jpg',
                        'Skybox/Cloudy/bluecloud_dn.jpg',
                        'Skybox/Cloudy/bluecloud_ft.jpg',
                        'Skybox/Cloudy/bluecloud_lf.jpg',
                        'Skybox/Cloudy/bluecloud_rt.jpg',
                        'Skybox/Cloudy/bluecloud_up.jpg'
                    ]);
                    break;
                
                case 'interstellar':
                    var skybox = loader.load([
                        'Skybox/Interstellar/interstellar_bk.png',
                        'Skybox/Interstellar/interstellar_dn.png',
                        'Skybox/Interstellar/interstellar_ft.png',
                        'Skybox/Interstellar/interstellar_lf.png',
                        'Skybox/Interstellar/interstellar_rt.png',
                        'Skybox/Interstellar/interstellar_up.png'
                    ]);
                    break;
                case 'space':
                    var skybox = loader.load([
                        'Skybox/Space/space_bk.png',
                        'Skybox/Space/space_dn.png',
                        'Skybox/Space/space_ft.png',
                        'Skybox/Space/space_lf.png',
                        'Skybox/Space/space_rt.png',
                        'Skybox/Space/space_up.png'
                    ]);
                    break;
                case 'sunset':
                    var skybox = loader.load([
                        'Skybox/Sunset/yellowcloud_bk.jpg',
                        'Skybox/Sunset/yellowcloud_dn.jpg',
                        'Skybox/Sunset/yellowcloud_ft.jpg',
                        'Skybox/Sunset/yellowcloud_lf.jpg',
                        'Skybox/Sunset/yellowcloud_rt.jpg',
                        'Skybox/Sunset/yellowcloud_up.jpg'
                    ]);
                    break;
            }

            scene.background = skybox;
        }

         

        let skyboxGeo;
        var whiteTakenPieces = new TakenPieces('W');
        var blackTakenPieces = new TakenPieces('B');

        function init() {

            // scene
            scene = new THREE.Scene();

            // renderer
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // camera
            var ratio = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(45, ratio, 0.1, 1000);
            camera.position.set(3.5, 10, 3); //initial position of the camera
            camera.lookAt(3.5, 0, -3.5);
            camera.lookAt(3.5, 0, -3.5);
            camera.updateProjectionMatrix();

            // resize
            window.addEventListener('resize', function () {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            });

            // ambient light
            const color = 0xFFFFFF;
            const intensity = 1;
            const light = new THREE.AmbientLight(color, intensity);
            scene.add(new THREE.AmbientLight(0x404040));
            scene.add(light);

            // directional light
            const dl = new THREE.DirectionalLight(0xffffff, 0.5);
            dl.position.set(0, 2, 2);
            scene.add(dl);

            // gui
            const gui = new dat.GUI();

            var temp;
            var data = {
                background: "cloudy",
                presetLighting: false
            }

            // light intensity slider
            const folderlight = gui.addFolder("Light");
            folderlight.add(light, 'intensity', 0, 2, 0.1);
            folderlight.add(dl.position, 'y', 0.1, 5, 0.1);

            // color slider
            const folderpieces = gui.addFolder("Pieces");

            folderpieces.addColor(new ColorGUIHelper(whitePieceMaterial, 'color'), 'value').name('WhitePiece');
            folderpieces.addColor(new ColorGUIHelper(blackPieceMaterial, 'color'), 'value').name('BlackPiece');

            const folderboard = gui.addFolder("Board");
            folderboard.addColor(new ColorGUIHelper(blackTileMaterial, 'color'), 'value').name('BlackTile');
            folderboard.addColor(new ColorGUIHelper(whiteTileMaterial, 'color'), 'value').name('WhiteTile');


            const folderbackground = gui.addFolder("Background");
            var selectedSkybox = folderbackground.add(data, 'background', ['cloudy', 'interstellar', 'space', 'sunset']).name("Backgrounds");

            selectedSkybox.onChange(function(temp){
                addSkybox(temp);
            });


            const folderTextures = gui.addFolder("Textures");

            folderTextures.add(blackPieceMaterial, 'map', Object.keys(pieceTextures)).name('Black Piece').onChange((value) => {

                blackPieceMaterial.map = pieceTextures[value].color;
                blackPieceMaterial.needsUpdate = true;
            });
            folderTextures.add(whitePieceMaterial, 'map', Object.keys(pieceTextures)).name('White Piece').onChange((value) => {

                whitePieceMaterial.map = pieceTextures[value].color;
                whitePieceMaterial.needsUpdate = true;
            });
            folderTextures.add(blackTileMaterial, 'map', Object.keys(pieceTextures)).name('Black Square').onChange((value) => {

                blackTileMaterial.map = pieceTextures[value].color;
                blackTileMaterial.needsUpdate = true;
            });
            folderTextures.add(whiteTileMaterial, 'map', Object.keys(pieceTextures)).name('White Square').onChange((value) => {

                whiteTileMaterial.map = pieceTextures[value].color;
                whiteTileMaterial.needsUpdate = true;
            });

            CreateBoard();
        }

        var tileGeometry = new THREE.BoxGeometry(1, 0.1, 1);
        var checkTileMaterial = new THREE.MeshBasicMaterial({ color: checkTileColour });

        function CreateBoard() {

            game_group = new THREE.Group();

            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    let tile = new Tile(PosToFile(i), PosToRank(j));
                    var tileColour;
                    var tileMaterial;
                    if (j % 2) {
                        if (i % 2) {
                            tileColour = 'B';
                            tileMaterial = blackTileMaterial;
                        } else {
                            tileColour = 'W';
                            tileMaterial = whiteTileMaterial;
                        }
                    } else {
                        if (i % 2) {
                            tileColour = 'W';
                            tileMaterial = whiteTileMaterial;
                            tile.setColour(whiteTileColour);
                        } else {
                            tileColour = 'B';
                            tileMaterial = blackTileMaterial;
                        }
                    }
                    tile.setColour(tileColour);
                    tile.setMesh(new THREE.Mesh(tileGeometry, tileMaterial))
                    tile.setOriginalMaterial(tileMaterial);
                    tile.getMesh().position.set(i, 0, -j);
                    board.tilemap[i][j] = tile;
                    game_group.add(tile.getMesh());
                }
            }
            PlacePieces();
            scene.add(game_group);
        }

        //variables to keep the models in memory


        function loadModels() {
            return new Promise(
                (ok, no) => {
                    const loader = new THREE.GLTFLoader();
                    loader.load("./models/chess_complete.glb",
                        (gltf) => {
                            model_board = gltf.scene.getObjectByName("BOARD");
                            model_pawn = gltf.scene.getObjectByName("PAWN");
                            model_knight = gltf.scene.getObjectByName("KNIGHT");
                            model_rook = gltf.scene.getObjectByName("ROOK");
                            model_king = gltf.scene.getObjectByName("QUEEN");
                            model_queen = gltf.scene.getObjectByName("KING");
                            model_bishop = gltf.scene.getObjectByName("BISHOP");


                            ok()
                        }
                    );
                    loadTextureSet("Rock");
                    loadTextureSet("Glass");
                    loadTextureSet("Marble");
                    loadTextureSet("Wood");
                }

            );

        }

        function RankToPos(rank) {
            return --rank;
        }

        function FileToPos(file) {
            let files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            return files.indexOf(file);
        }

        function PosToRank(pos) {
            return ++pos;
        }

        function PosToFile(pos) {
            if (pos > 7) pos = 7;
            else if (pos < 0) pos = 0;
            var files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            return files[pos];
        }

        function FindTile(file, rank) {
            return board.tilemap[FileToPos(file)][RankToPos(rank)];
        }

        // animation loop
        function animate() {
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        function StorePGN(pgn) {
            // "1. e4 Nf6 2. f3 e5" becomes [1., e4, Nf6, 2., f3, e5]
            var moveArray;
            moveArray = pgn.split(/\s+/);
            return moveArray;
        }

        function CreatePiece(color, model, name, row, column) {
            // creates a piece cloning the model and set to a position in row, column
            var pieces;
            if (color === 'W') {
                pieces = white_pieces; // set to the list of white's pieces
                pieces[name] = model.clone();
                pieces[name].material = whitePieceMaterial;
                pieces[name].position.set(row, 0, -column); // assign the position 
                game_group.add(pieces[name]);
            } else if (color === 'B') {
                pieces = black_pieces; // set to the list of black's pieces
                pieces[name] = model.clone();
                pieces[name].material = blackPieceMaterial;
                pieces[name].position.set(row, 0, -column);
                pieces[name].rotation.y = Math.PI; // rotate facing towards whites
                game_group.add(pieces[name]);
            }
            return pieces[name];
        }

        function PlacePieces() {
            // two-loop for assigning each piece in the board
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    let name = pieceMap[7 - i][j]; //  get the piece position from the corresponding cell in the board 2d array
                    if (name === "") {
                        continue;
                    }
                    let color = name.charAt(0); // get the color, W or B
                    let piece = name.charAt(1); // get the piece type, P, K, H, T, Q, R
                    let number = name.charAt(2); // get the corresponding identifier number

                    let tile = board.tilemap[j][i];
                    var newPiece;
                    switch (piece) {
                        case 'P':
                            newPiece = new Piece(piece, tile, CreatePiece(color, model_pawn, name, j, i), color);
                            break;
                        case 'K':
                            newPiece = new Piece(piece, tile, CreatePiece(color, model_king, name, j, i), color);
                            break;
                        case 'N':
                            newPiece = new Piece(piece, tile, CreatePiece(color, model_knight, name, j, i), color);
                            break;
                        case 'R':
                            newPiece = new Piece(piece, tile, CreatePiece(color, model_rook, name, j, i), color);
                            break;
                        case 'Q':
                            newPiece = new Piece(piece, tile, CreatePiece(color, model_queen, name, j, i), color);
                            break;
                        case 'B':
                            newPiece = new Piece(piece, tile, CreatePiece(color, model_bishop, name, j, i), color);
                            break;
                    }
                    tile.setPiece(newPiece);
                }
            }
        }

        async function StartGame(pgnArray) {
            let colour = 'W';
            for (var i = 0; i < pgnArray.length - 1; i++) {
                // ignore the 1., 2. elements
                if (i % 3 == 0 || i == 0) continue;

                await waitingSpaceKeypress();

                DoCommand(pgnArray[i], colour);
                colour = (colour === 'W') ? 'B' : 'W';
            }
            TriggerWin(pgnArray[pgnArray.length - 1]);
        }
        function waitingSpaceKeypress() {
            return new Promise((resolve) => {
                document.addEventListener("keydown", onKeyHandler);
                function onKeyHandler(e) {
                    if (e.keyCode === 0 || e.keyCode === 32) {
                        document.removeEventListener('keydown', onKeyHandler);
                        PlaySound();
                        resolve();
                    }
                }
            })
        }

        function TriggerWin(winner) {
            let textBox = document.getElementById("TextBox");
            textBox.style.visibility = "visible";
            if (winner === "1-0") {
                textBox.innerHTML = "Checkmate: White wins";
            }
            else {
                textBox.innerHTML = "Checkmate: Black wins";
                textBox.style.color = 0x000000;
            }
        }

        var skipTestCheck = true;
        function DoCommand(command, colour) {
            console.log(command);
            if (skipTestCheck == false) {
                TestCheck();
                skipTestCheck = true;
            }
            // Check Contains (+: Check, #: Checkmate, 0-0-0: Castle Queen, 0-0: Castle King, =: Promote pawn, x: takes)
            if (command.includes('+')) {
                // Handle Check
                DoCheck(colour);
                // Remove '+'
                command = command.replace('+', '');
                // On repeated calls, TestCheck() wont be called, so the check wont be immediately undone.
                skipTestCheck = true;
                // Call CheckCommand again
                DoCommand(command, colour);
                // Calls after will now undo the check
                skipTestCheck = false;
                // Return so that DoBasicCommand() isn't called twice
                return;
            }
            else if (command.includes('#')) {
                DoCheck(colour);
                command = command.replace('#', '');
                DoCommand(command, colour);
                return;
            }

            if (command.includes("O-O-O")) {
                DoCastleQueen(colour);
                return;
            }
            else if (command.includes("O-O")) {
                DoCastleKing(colour);
                return;
            }

            if (command.includes('=')) {
                DoPromotePawn(command, colour);
                // Remove '=' and last char
                command = command.slice(0, command.length - 2);
                DoCommand(command, colour);
                return;
            }

            if (command.includes('x')) {
                // Remove Piece at pos of last 2 char
                let takenPiece = FindTile(command.charAt(command.length - 2), command.charAt(command.length - 1)).getPiece();
                DoTakePiece(takenPiece);
                command = command.replace('x', '');
                DoCommand(command, colour);
                return;
            }
            DoBasicCommand(command, colour);
        }

        function TestCheck() {
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    let tempTile = board.tilemap[i][j];
                    if (tempTile.getPiece() == undefined) continue;
                    if (tempTile.getPiece().getType() == 'K') {
                        if (Object.is(tempTile.getMesh().material, checkTileMaterial)) tempTile.getMesh().material = tempTile.getOriginalMaterial();
                    }
                }
            }
        }

        function DoCheck(colour) {
            // return;
            var kingPiece;
            var kingTile;
            let highlightColour = checkTileColour;
            let breakLoop = false;
            if (colour === 'W') {
                // Look for black King tile
                for (let i = 0; i < 8; i++) {
                    if (breakLoop) break;
                    for (let j = 0; j < 8; j++) {
                        if (breakLoop) break;
                        kingPiece = board.tilemap[i][j].getPiece();
                        if (!kingPiece || kingPiece.getType() != 'K' || kingPiece.getColour() != 'B') continue;
                        breakLoop = true;
                    }
                }
                kingTile = kingPiece.getTile();
            }
            else {
                // Look for white King
                for (let i = 0; i < 8; i++) {
                    if (breakLoop) break;
                    for (let j = 0; j < 8; j++) {
                        if (breakLoop) break;
                        kingPiece = board.tilemap[i][j].getPiece();
                        if (!kingPiece || kingPiece.getType() != 'K' || kingPiece.getColour() != 'W') continue;
                        breakLoop = true;
                    }
                }
                kingTile = kingPiece.getTile();
            }
            // Highlight King tile
            kingTile.getMesh().material = checkTileMaterial;
        }

        function DoCastleQueen(colour) {
            var kingPiece;
            var rookPiece;
            // if white
            if (colour === 'W') {
                // Find King
                kingPiece = FindTile('e', 1).piece;
                // Find Rook
                rookPiece = FindTile('a', 1).piece;
                // Move King 2 Left
                MovePiece(kingPiece, 'c', 1);
                // Move Rook 3 Right
                MovePiece(rookPiece, 'd', 1);
            }
            else {
                kingPiece = FindTile('e', 8).piece;
                rookPiece = FindTile('a', 8).piece;
                MovePiece(kingPiece, 'c', 8);
                MovePiece(rookPiece, 'd', 8);
            }
        }

        function DoCastleKing(colour) {
            var kingPiece;
            var rookPiece;
            // if white
            if (colour === 'W') {
                // Find King
                kingPiece = FindTile('e', 1).piece;
                // Find Rook
                rookPiece = FindTile('h', 1).piece;
                // Move King 2 Right
                MovePiece(kingPiece, 'g', 1);
                // Move Rook 3 Left
                MovePiece(rookPiece, 'f', 1);
            }
            else {
                kingPiece = FindTile('e', 8).piece;
                rookPiece = FindTile('h', 8).piece;
                MovePiece(kingPiece, 'g', 8);
                MovePiece(rookPiece, 'f', 8);
            }
        }

        function DoPromotePawn(command, colour) {
            let newPieceType = command.charAt(command.length - 1);
            var rank;
            if (colour === 'W') {
                rank = 7;
            }
            else {
                rank = 2;
            }
            let file = command.charAt(0);
            let pawnTile = FindTile(file, rank);
            // Remove Pawn
            game_group.remove(pawnTile.getPiece().getMesh());
            // Add new Piece depending on last letter
            var model;
            switch (newPieceType) {
                case 'Q':
                    model = model_queen;
                    break;
                case 'N':
                    model = model_knight;
                    break;
                case 'B':    
                    model = model_bishop;
                    break;
                default:
                    model = model_rook;
                    break;
            }
            pawnTile.setPiece(new Piece(newPieceType, pawnTile, CreatePiece(colour, model, '', pawnTile.getFile(), rank), colour));
        }

        function DoTakePiece(takenPiece) {
            // Remove piece at takenTile
            // Move it to TakenPieces of same colour
            if (takenPiece.colour === 'W') {
                whiteTakenPieces.addPiece(takenPiece);
            }
            else {
                blackTakenPieces.addPiece(takenPiece);
            }
        }

        function DoBasicCommand(command, colour) {
            // endFile/x-axis = 2nd last char
            let endFile = command.charAt(command.length - 2);
            // endRank/y-axis = last char
            let endRank = parseInt(command.charAt(command.length - 1));

            // target = piece to move
            var target;
            var disambiguator;

            // if 2 char -- e4
            if (command.length == 2) {
                let pawnRank = endRank - 1;
                var tempTile;
                // Look for Pawn
                // Set target to Pawn
                if (colour === 'W') {
                    tempTile = FindTile(endFile, endRank - 1);
                    if (tempTile.getPiece() == undefined) tempTile = FindTile(endFile, endRank - 2);
                    target = tempTile.getPiece();
                }
                else {
                    tempTile = FindTile(endFile, endRank + 1);
                    if (tempTile.getPiece() == undefined) tempTile = FindTile(endFile, endRank + 2);
                    target = tempTile.getPiece();
                }
            }
            // if 3 char -- Qe4 / de4
            else if (command.length == 3) {
                // Look for piece of type 1st char
                // Type of piece is specified in first char as UpperCase
                var type = command.charAt(0);
                if (IsUpperCase(type)) {
                    target = LookForPieceToMove(type, colour, endFile, endRank);
                }
                // If type is not UpperCase, type must be pawn and file is specified
                else {
                    var pawnTile;
                    if (colour === 'W') {
                        target = FindTile(type, endRank-1).getPiece();
                    }
                    else target = FindTile(type, endRank+1).getPiece();
                }
            }
            // if 4 char -- Qde4/Q3e4
            else if (command.length == 4) {
                let type = command.charAt(0);
                // Look for piece of type 1st char on 2nd char rank/file
                disambiguator = command.charAt(1);
                if (!(/[a-h]/).test(disambiguator)) disambiguator = parseInt(disambiguator);

                target = LookForPieceToMove(type, colour, endFile, endRank, disambiguator);
            }
            // if 5 char -- Qd3e4
            else {
                // Look for piece at position (2nd, 3rd)
                // Move piece to destination
                var file = command.charAt(1);
                var rank = command.charAt(2);
                target = FindTile(file, rank).getPiece();
            }

            MovePiece(target, endFile, endRank);
        }

        function IsUpperCase(str) {
            if (str.toUpperCase() === str) return true;
            return false;
        }

        // This function will always be called with both type paramanter as a single upper-case character eg, "R"
        // and colour paramater as a string, either "W" or "B"
        // Function returns the reference to the piece.
        function LookForPieceToMove(type, colour, endFile, endRank, disambiguator) {
            var pieceToReturn;
            let mult = 1;
            let stopN = false;
            let stopNE = false;
            let stopE = false;
            let stopSE = false;
            let stopS = false;
            let stopSW = false;
            let stopW = false;
            let stopNW = false;
            switch (type) {
                // look for king
                case 'K':
                    // from tile, look in every direction once
                    // if you are in bounds, search in that direction for the 
                    if (endRank != 8) pieceToReturn = SearchN(type, colour, endFile, endRank, mult);
                    if (!pieceToReturn && endFile != 'h' && endRank != 8) pieceToReturn = SearchNE(type, colour, endFile, endRank, mult);
                    if (!pieceToReturn && endFile != 'h') pieceToReturn = SearchE(type, colour, endFile, endRank, mult);
                    if (!pieceToReturn && endFile != 'h' && endRank != 1) pieceToReturn = SearchSE(type, colour, endFile, endRank, mult);
                    if (!pieceToReturn && endRank != 1) pieceToReturn = SearchS(type, colour, endFile, endRank, mult);
                    if (!pieceToReturn && endFile != 'a' && endRank != 1) pieceToReturn = SearchSW(type, colour, endFile, endRank, mult);
                    if (!pieceToReturn && endFile != 'a') pieceToReturn = SearchW(type, colour, endFile, endRank, mult);
                    if (!pieceToReturn && endFile != 'a' && endRank != 8) pieceToReturn = SearchNW(type, colour, endFile, endRank, mult);
                    break;
                // look for queen
                case 'Q':
                    // from tile, look N,NE,E,SE,S,SW,W,NW until found
                    while (!pieceToReturn) {

                        if (!stopN && !pieceToReturn && (endRank + mult - 1) < 8) pieceToReturn = SearchN(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopN = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopNE && !pieceToReturn && PosToFile(FileToPos(endFile) + mult - 1) != 'h' && (endRank + mult - 1) < 8) pieceToReturn = SearchNE(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopNE = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopE && !pieceToReturn && PosToFile(FileToPos(endFile) + mult - 1) != 'h') pieceToReturn = SearchE(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopE = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopSE && !pieceToReturn && PosToFile(FileToPos(endFile) + mult - 1) != 'h' && (endRank - mult + 1) > 1) pieceToReturn = SearchSE(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopSE = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopS && !pieceToReturn && (endRank - mult + 1) > 1) pieceToReturn = SearchS(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopS = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopSW && !pieceToReturn && PosToFile(FileToPos(endFile) - mult + 1) != 'a' && (endRank - mult + 1) > 1) pieceToReturn = SearchSW(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopSW = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopW && !pieceToReturn && PosToFile(FileToPos(endFile) - mult + 1) != 'a') pieceToReturn = SearchW(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopW = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopNW && !pieceToReturn && PosToFile(FileToPos(endFile) - mult + 1) != 'a' && (endRank + mult - 1) < 8) pieceToReturn = SearchNW(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopNW = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (mult > 7) break;
                        mult++;
                    }

                    break;
                // look for rook
                case 'R':
                    // from tile, look N,E,S,W until found
                    while (!pieceToReturn) {
                        if (!stopN && !pieceToReturn && (endRank + mult - 1) < 8) pieceToReturn = SearchN(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopN = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopE && !pieceToReturn && PosToFile(FileToPos(endFile) + mult - 1) != 'h') pieceToReturn = SearchE(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopE = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopS && !pieceToReturn && (endRank - mult + 1) > 1) pieceToReturn = SearchS(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopS = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopW && !pieceToReturn && PosToFile(FileToPos(endFile) - mult + 1) != 'a') pieceToReturn = SearchW(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopW = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        mult++;
                    }

                    break;
                // look for bishop
                case 'B':
                    // from tile, look NE,SE,SW,NW
                    while (!pieceToReturn) {
                        if (!stopNE && !pieceToReturn && PosToFile(FileToPos(endFile) + mult - 1) != 'h' && (endRank + mult - 1) < 8) pieceToReturn = SearchNE(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopNE = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopSE && !pieceToReturn && PosToFile(FileToPos(endFile) + mult - 1) != 'h' && (endRank - mult + 1) > 1) pieceToReturn = SearchSE(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopSE = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopSW && !pieceToReturn && PosToFile(FileToPos(endFile) - mult + 1) != 'a' && (endRank - mult + 1) > 1) pieceToReturn = SearchSW(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopSW = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopNW && !pieceToReturn && PosToFile(FileToPos(endFile) - mult + 1) != 'a' && (endRank + mult - 1) < 8) pieceToReturn = SearchNW(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopNW = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        mult++;
                    }

                    break;
                // look for knight
                case 'N':
                    // from tile, look in L
                    if (endFile != 'g' && endFile != 'h' && endRank < 8) pieceToReturn = SearchKnight1(type, colour, endFile, endRank, 1);
                    if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                    if (!pieceToReturn && endFile != 'a' && endFile != 'b' && endRank > 1) pieceToReturn = SearchKnight1(type, colour, endFile, endRank, -1);
                    if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                    if (!pieceToReturn && endFile != 'h' && endRank < 7) pieceToReturn = SearchKnight1(type, colour, endFile, endRank, 2);
                    if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                    if (!pieceToReturn && endFile != 'a' && endRank > 2) pieceToReturn = SearchKnight1(type, colour, endFile, endRank, -2);
                    if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                    if (!pieceToReturn && endFile != 'a' && endFile != 'b' && endRank < 8) pieceToReturn = SearchKnight2(type, colour, endFile, endRank, 1);
                    if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                    if (!pieceToReturn && endFile != 'g' && endFile != 'h' && endRank > 1) pieceToReturn = SearchKnight2(type, colour, endFile, endRank, -1);
                    if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                    if (!pieceToReturn && endFile != 'a' && endRank < 7) pieceToReturn = SearchKnight2(type, colour, endFile, endRank, 2);
                    if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                    if (!pieceToReturn && endFile != 'h' && endRank > 2) pieceToReturn = SearchKnight2(type, colour, endFile, endRank, -2);

                    break;
                // look for pawn
                default:
                    // from tile, look above
                    if (colour === 'W') {
                        if (endFile != 'h' && endRank > 1) pieceToReturn = SearchSE(type, colour, endFile, endRank, mult);
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                        if (!pieceToReturn && endFile != 'a' && endRank > 1) pieceToReturn = SearchSW(type, colour, endFile, endRank, mult);
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                    }
                    else {
                        if (endFile != 'h' && endRank < 8) pieceToReturn = SearchNE(type, colour, endFile, endRank, mult);
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                        if (!pieceToReturn && endFile != 'a' && endRank < 8) pieceToReturn = SearchNW(type, colour, endFile, endRank, mult);
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                    }

                    break;
            }

            return pieceToReturn;
        }

        function SearchTile(type, colour, file, rank, fileOffset, rankOffset) {
            let newFile = PosToFile(FileToPos(file) + fileOffset);
            let newRank = rank + rankOffset;

            return FindTile(newFile, newRank).getPiece();
        }

        function SearchN(type, colour, endFile, endRank, mult, looped) {
            let tempPiece = SearchTile(type, colour, endFile, endRank, 0 * mult, 1 * mult);
            if (looped) return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : true;
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        function SearchNE(type, colour, endFile, endRank, mult, looped) {
            let tempPiece = SearchTile(type, colour, endFile, endRank, 1 * mult, 1 * mult);
            if (looped) return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : true;
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        function SearchE(type, colour, endFile, endRank, mult, looped) {
            let tempPiece = SearchTile(type, colour, endFile, endRank, 1 * mult, 0 * mult);
            if (looped) return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : true;
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        function SearchSE(type, colour, endFile, endRank, mult, looped) {
            let tempPiece = SearchTile(type, colour, endFile, endRank, 1 * mult, -1 * mult);
            if (looped) return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : true;
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        function SearchS(type, colour, endFile, endRank, mult, looped) {
            let tempPiece = SearchTile(type, colour, endFile, endRank, 0 * mult, -1 * mult);
            if (looped) return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : true;
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        function SearchSW(type, colour, endFile, endRank, mult, looped) {
            let tempPiece = SearchTile(type, colour, endFile, endRank, -1 * mult, -1 * mult);
            if (looped) return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : true;
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        function SearchW(type, colour, endFile, endRank, mult, looped) {
            let tempPiece = SearchTile(type, colour, endFile, endRank, -1 * mult, 0 * mult);
            if (looped) return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : true;
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        function SearchNW(type, colour, endFile, endRank, mult, looped) {
            let tempPiece = SearchTile(type, colour, endFile, endRank, -1 * mult, 1 * mult);
            if (looped) return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : true;
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        function SearchKnight1(type, colour, endFile, endRank, mult) {
            let tempPiece = SearchTile(type, colour, endFile, endRank, 2 / mult, 1 * mult);
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        function SearchKnight2(type, colour, endFile, endRank, mult) {
            let tempPiece = SearchTile(type, colour, endFile, endRank, -2 / mult, 1 * mult);
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        function CheckDisambiguator(pieceToCheck, disambiguator) {
            if (!pieceToCheck) return true;
            if (!disambiguator) return true;
            return ((pieceToCheck.getTile().getFile() === disambiguator || pieceToCheck.getTile().getRank() === disambiguator)) ? true : false;
        }

        function MovePiece(target, endFile, endRank) {
            // Old tile should dereference the piece.
            target.getTile().setPiece(undefined);
            // Change the tile that the piece points to.
            target.setTile(FindTile(endFile, endRank));
            // New tile should reference piece.
            target.getTile().setPiece(target);
            target.updatePosition();
        }

        function PlaySound() {
            let path = '/sounds/check.mp3';
            let ele = new Audio(path);
            ele.play();
        }
    </script>
</body>

</html>