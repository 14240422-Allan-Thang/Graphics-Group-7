<html>
<head>
    <title>Chess Project</title>
</head>

<style>
    body {margin: 0;}
    canvas {width: 100%; height: 100%}
</style>

<body>
    <script src="js/three.js"> </script>
    <script src="js/OrbitControls.js"> </script>
    <script src="js/STLLoader.js"></script>

    <style>
        body {
            font-family: Monospace;
            background-color: #000;
            color: #fff;
            margin: 0px;
            overflow: hidden;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
        }
    </style>

    <div>
        <p>Chess Project</p>
    </div>

    <!-- <button id="SoundButton" onclick="PlaySound()">Click Me</button> -->

    <div id="TextBox" style="visibility:hidden"></div>

    <script>
        
        //holds the pieces of each player, whites and blacks
        var black_pieces={};
        var white_pieces={};
        let whiteTileColour = new THREE.Color(0xffffff);
        let blackTileColour = new THREE.Color(0x000000);
        let checkTileColour = new THREE.Color(0xd61b1b);

        /* StorePGN should write the proper pieces in the array board with the format of "BP0" for black pawn 0 */
        /* 
            B for black, W for white,
            R for rook, K for knight, B for bishop, K for king, Q for queen, P for pawn
            0 .. 7 the number of the pieces which are duplicated in each color,
            0 for the ones on the left hand, 1 for the ones on  the right hand, 
        */
        let pieceMap = [
          ["BR0", "BN0", "BB0", "BQ", "BK", "BB1", "BN1", "BR1"],
          ["BP0", "BP1", "BP2", "BP3", "BP4", "BP5", "BP6", "BP7"],
          ["", "", "", "", "", "", "", ""],
          ["", "", "", "", "", "", "", ""],
          ["", "", "", "", "", "", "", ""],
          ["", "", "", "", "", "", "", ""],
          ["WP0", "WP1", "WP2", "WP3", "WP4", "WP5", "WP6", "WP7"],
          ["WR0", "WN0", "WB0", "WQ", "WK", "WB1", "WN1", "WR1"]
        ];
        const Board = {
            tilemap: [],
        };
        
        board = Board;
        board.tilemap = new Array(8);
        for (let i = 0; i < 8; i++) {
            board.tilemap[i] = new Array(8);
        }

        class Tile {
            constructor(file, rank) {
                this.file = file;
                this.rank = rank;
                this.colour;
                this.piece;
                this.mesh;
                this.originalMaterial;
            }
            getColour() {
                return this.colour;
            }
            setColour(value) {
                this.colour = value;
            }
            getRank() {
                return this.rank;
            }
            getFile() {
                return this.file;
            }
            getPiece() {
                return this.piece;
            }
            setPiece(value) {
                this.piece = value;
            }
            getMesh() {
                return this.mesh;
            }
            setMesh(value) {
                this.mesh = value;
            }
            getOriginalMaterial() {
                return this.originalMaterial;
            }
            setOriginalMaterial(value) {
                this.originalMaterial = value;
            }
        }

        class Piece {
            constructor(type, tile, mesh, colour) {
                this.type = type;
                this.tile = tile;
                this.mesh = mesh;
                this.colour = colour;
            }
            getType() {
                return this.type;
            }
            getTile() {
                return this.tile;
            }
            setTile(value) {
                this.tile = value;
            }
            getColour() {
                return this.colour;
            }
            setColour(value) {
                this.colour = value;
            }
            getMesh() {
                return this.mesh;
            }
            setMesh(value) {
                this.mesh = value;
            }
            updatePosition() {
                this.mesh.position.set(FileToPos(this.tile.getFile()), 0, (RankToPos(this.tile.getRank()) * -1));
            }
        }

        class TakenPieces {
            constructor(colour) {
                this.colour = colour;
                this.pieces = [];
            }
            getPieces() {
                return this.pieces;
            }
            setPieces(value) {
                this.pieces = value;
            }
            addPiece(value) {
                this.pieces.push(value);
            }
        }
        var scene, camera, renderer;
        let loader = new THREE.STLLoader();
        let material = new THREE.MeshPhongMaterial({ color: 0x55B663 });
        var board, game_group;

        //make the script wait until all the pieces are loaded before initializing the game and rendering
        loadModels().then(
            function() {
                init();
                animate();
            }
        );
        
        function init() {
            
            // scene
            scene = new THREE.Scene();

            // renderer
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            // camera
            var ratio = window.innerWidth/window.innerHeight;
            camera = new THREE.PerspectiveCamera(45,ratio,0.1,1000);
            camera.position.set(3.5,10,3); //initial position of the camera
            camera.lookAt(3.5,0,-3.5);
            camera.lookAt(3.5,0,-3.5);
            camera.updateProjectionMatrix();

            // resize
            window.addEventListener('resize', function() {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth, window.innerHeight;
                camera.updateProjectionMatrix();
            });

            // lights
            var light = new THREE.PointLight(new THREE.Color(1,1,1), 1);
            light.position.set(5,5,0)
            scene.add(new THREE.AmbientLight(0x404040));
            scene.add(light);
            
            //controls
            // controls = new THREE.OrbitControls( camera, renderer.domElement );
            
            //axes. uncomment below line to show axes
            // scene.add(new THREE.AxesHelper(20));

            // var geometry = new THREE.BoxGeometry(1, 1, 1);
            // var material = new THREE.MeshBasicMaterial({color: new THREE.Color(0xffffff)});
            // var mesh = new THREE.Mesh(geometry, material);
            // mesh.position.set(0,0,1);
            // scene.add(mesh);
            
            let string = "1. e4 e5 2. Bc4 Nc6 3. Qh5 Nf6 4. Qxf7# 1-0";
            let basicGame = "1. h4 e5 2. e4 Bc5 3. Nc3 Qxh4 4. Nf3 Qxf2# 0-1";
            let KasparovVsTopalov1999 = "1. e4 d6 2. d4 Nf6 3. Nc3 g6 4. Be3 Bg7 5. Qd2 c6 6. f3 b5 7. Nge2 Nbd7 8. Bh6 Bxh6 9. Qxh6 Bb7 10. a3 e5 11. O-O-O Qe7 12. Kb1 a6 13. Nc1 O-O-O 14. Nb3 exd4 15. Rxd4 c5 16. Rd1 Nb6 17. g3 Kb8 18. Na5 Ba8 19. Bh3 d5 20. Qf4+ Ka7 21. Rhe1 d4 22. Nd5 Nbxd5 23. exd5 Qd6 24. Rxd4 cxd4 25. Re7+ Kb6 26. Qxd4+ Kxa5 27. b4+ Ka4 28. Qc3 Qxd5 29. Ra7 Bb7 30. Rxb7 Qc4 31. Qxf6 Kxa3 32. Qxa6+ Kxb4 33. c3+ Kxc3 34. Qa1+ Kd2 35. Qb2+ Kd1 36. Bf1 Rd2 37. Rd7 Rxd7 38. Bxc4 bxc4 39. Qxh8 Rd3 40. Qa8 c3 41. Qa4+ Ke1 42. f4 f5 43. Kc1 Rd2 44. Qa7 1-0";
            let MorphyVsAllies1858 = "1. e4 e5 2. Nf3 d6 3. d4 Bg4 4. dxe5 Bxf3 5. Qxf3 dxe5 6. Bc4 Nf6 7. Qb3 Qe7 8. Nc3 c6 9. Bg5 b5 10. Nxb5 cxb5 11. Bxb5+ Nbd7 12. O-O-O Rd8 13. Rxd7 Rxd7 14. Rd1 Qe6 15. Bxd7+ Nxd7 16. Qb8+ Nxb8 17. Rd8# 1-0";
            let AronianVsAnand2013 = "1. d4 d5 2. c4 c6 3. Nf3 Nf6 4. Nc3 e6 5. e3 Nbd7 6. Bd3 dxc4 7. Bxc4 b5 8. Bd3 Bd6 9. O-O O-O 10. Qc2 Bb7 11. a3 Rc8 12. Ng5 c5 13. Nxh7 Ng4 14. f4 cxd4 15. exd4 Bc5 16. Be2 Nde5 17. Bxg4 Bxd4+ 18. Kh1 Nxg4 19. Nxf8 f5 20. Ng6 Qf6 21. h3 Qxg6 22. Qe2 Qh5 23. Qd3 Be3 0-1";
            let KarpovVsKasparov1985 = "1. e4 c5 2. Nf3 e6 3. d4 cxd4 4. Nxd4 Nc6 5. Nb5 d6 6. c4 Nf6 7. N1c3 a6 8. Na3 d5 9. cxd5 exd5 10. exd5 Nb4 11. Be2 Bc5 12. O-O O-O 13. Bf3 Bf5 14. Bg5 Re8 15. Qd2 b5 16. Rad1 Nd3 17. Nab1 h6 18. Bh4 b4 19. Na4 Bd6 20. Bg3 Rc8 21. b3 g5 22. Bxd6 Qxd6 23. g3 Nd7 24. Bg2 Qf6 25. a3 a5 26. axb4 axb4 27. Qa2 Bg6 28. d6 g4 29. Qd2 Kg7 30. f3 Qxd6 31. fxg4 Qd4+ 32. Kh1 Nf6 33. Rf4 Ne4 34. Qxd3 Nf2+ 35. Rxf2 Bxd3 36. Rfd2 Qe3 37. Rxd3 Rc1 38. Nb2 Qf2 39. Nd2 Rxd1+ 40. Nxd1 Re1+ 0-1";
            let ByrneVsFischer1956 = "1. Nf3 Nf6 2. c4 g6 3. Nc3 Bg7 4. d4 O-O 5. Bf4 d5 6. Qb3 dxc4 7. Qxc4 c6 8. e4 Nbd7 9. Rd1 Nb6 10. Qc5 Bg4 11. Bg5 Na4 12. Qa3 Nxc3 13. bxc3 Nxe4 14. Bxe7 Qb6 15. Bc4 Nxc3 16. Bc5 Rfe8+ 17. Kf1 Be6 18. Bxb6 Bxc4+ 19. Kg1 Ne2+ 20. Kf1 Nxd4+ 21. Kg1 Ne2+ 22. Kf1 Nc3+ 23. Kg1 axb6 24. Qb4 Ra4 25. Qxb6 Nxd1 26. h3 Rxa2 27. Kh2 Nxf2 28. Re1 Rxe1 29. Qd8+ Bf8 30. Nxe1 Bd5 31. Nf3 Ne4 32. Qb8 b5 33. h4 h5 34. Ne5 Kg7 35. Kg1 Bc5+ 36. Kf1 Ng3+ 37. Ke1 Bb4+ 38. Kd1 Bb + 39. Kc1 Ne2+ 40. Kb1 Nc3+ 41. Kc1 Rc2# 0-1";
            let IvanchukVsYusupov1991 = "1. c4 e5 2. g3 d6 3. Bg2 g6 4. d4 Nd7 5. Nc3 Bg7 6. Nf3 Ngf6 7. O-O O-O 8. Qc2 Re8 9. Rd1 c6 10. b3 Qe7 11. Ba3 e4 12. Ng5 e3 13. f4 Nf8 14. b4 Bf5 15. Qb3 h6 16. Nf3 Ng4 17. b5 g5 18. bxc6 bxc6 19. Ne5 gxf4 20. Nxc6 Qg5 21. Bxd6 Ng6 22. Nd5 Qh5 23. h4 Nxh4 24. gxh4 Qxh4 25. Nde7+ Kh8 26. Nxf5 Qh + 27. Kf1 Re6 28. Qb7 Rg6 29. Qxa8+ Kh7 30. Qg8+ Kxg8 31. Nce7+ Kh7 32. Nxg6 fxg6 33. Nxg7 Nf2 34. Bxf4 Qxf4 35. Ne6 Qh2 36. Rdb1 Nh3 37. Rb7+ Kh8 38. Rb8+ Qxb8 39. Bxh3 Qg3 0-1";
            let ShortVsTmman1991 = "1. e4 Nf6 2. e5 Nd5 3. d4 d6 4. Nf3 g6 5. Bc4 Nb6 6. Bb3 Bg7 7. Qe2 Nc6 8. O-O O-O 9. h3 a5 10. a4 dxe5 11. dxe5 Nd4 12. Nxd4 Qxd4 13. Re1 e6 14. Nd2 Nd5 15. Nf3 Qc5 16. Qe4 Qb4 17. Bc4 Nb6 18. b3 Nxc4 19. bxc4 Re8 20. Rd1 Qc5 21. Qh4 b6 22. Be3 Qc6 23. Bh6 Bh8 24. Rd8 Bb7 25. Rad1 Bg7 26. R8d7 Rf8 27. Bxg7 Kxg7 28. R1d4 Rae8 29. Qf6+ Kg8 30. h4 h5 31. Kh2 Rc8 32. Kg3 Rce8 33. Kf4 Bc8 34. Kg5 1-0";
            let BaiJinshiVsDingLiren2017 = "1. d4 Nf6 2. c4 e6 3. Nc3 Bb4 4. Nf3 O-O 5. Bg5 c5 6. e3 cxd4 7. Qxd4 Nc6 8. Qd3 h6 9. Bh4 d5 10. Rd1 g5 11. Bg3 Ne4 12. Nd2 Nc5 13. Qc2 d4 14. Nf3 e5 15. Nxe5 dxc3 16. Rxd8 cxb2+ 17. Ke2 Rxd8 18. Qxb2 Na4 19. Qc2 Nc3+ 20. Kf3 Rd4 21. h3 h5 22. Bh2 g4+ 23. Kg3 Rd2 24. Qb3 Ne4+ 25. Kh4 Be7+ 26. Kxh5 Kg7 27. Bf4 Bf5 28. Bh6+ Kh7 29. Qxb7 Rxf2 30. Bg5 Rh8 31. Nxf7 Bg6+ 32. Kxg4 Ne5+ 0-1";
            let RotlewivsRubinstein1997 = "1. d4 d5 2. Nf3 e6 3. e3 c5 4. c4 Nc6 5. Nc3 Nf6 6. dxc5 Bxc5 7. a3 a6 8. b4 Bd6 9. Bb2 O-O 10. Qd2 Qe7 11. Bd3 dxc4 12. Bxc4 b5 13. Bd3 Rd8 14. Qe2 Bb7 15. O-O Ne5 16. Nxe5 Bxe5 17. f4 Bc7 18. e4 Rac8 19. e5 Bb6+ 20. Kh1 Ng4 21. Be4 Qh4 22. g3 Rxc3 23. gxh4 Rd2 24. Qxd2 Bxe4+ 25. Qg2 Rh3 0-1";
            let GellervsEuwe1953 = "1. d4 Nf6 2. c4 e6 3. Nc3 Bb4 4. e3 c5 5. a3 Bxc3+ 6. bxc3 b6 7. Bd3 Bb7 8. f3 Nc6 9. Ne2 O-O 10. O-O Na5 11. e4 Ne8 12. Ng3 cxd4 13. cxd4 Rc8 14. f4 Nxc4 15. f5 f6 16. Rf4 b5 17. Rh4 Qb6 18. e5 Nxe5 19. fxe6 Nxd3 20. Qxd3 Qxe6 21. Qxh7+ Kf7 22. Bh6 Rh8 23. Qxh8 Rc2 24. Rc1 Rxg2+ 25. Kf1 Qb3 26. Ke1 Qf3 0-1";
            
            pgn = StorePGN(MorphyVsAllies1858);
            
            CreateBoard();
            StartGame(pgn);
        }
        
        var tileGeometry = new THREE.BoxGeometry(1, 0.1, 1);
        var blackTileMaterial = new THREE.MeshBasicMaterial ({color: blackTileColour});
        var whiteTileMaterial = new THREE.MeshBasicMaterial ({color: whiteTileColour});
        var checkTileMaterial = new THREE.MeshBasicMaterial ({color: checkTileColour});
        function CreateBoard() {

            game_group = new THREE.Group();

            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    let tile = new Tile(PosToFile(i), PosToRank(j));
                    var tileColour;
                    var tileMaterial;
                    if (j % 2) {
                        if (i % 2) {
                            tileColour = 'B';
                            tileMaterial = blackTileMaterial;
                        } else {
                            tileColour = 'W';
                            tileMaterial = whiteTileMaterial;
                        }
                    } else {
                        if (i % 2) {
                            tileColour = 'W';
                            tileMaterial = whiteTileMaterial;
                            tile.setColour(whiteTileColour);
                        } else {
                            tileColour = 'B';
                            tileMaterial = blackTileMaterial;
                        }
                    }
                    tile.setColour(tileColour);
                    tile.setMesh(new THREE.Mesh(tileGeometry, tileMaterial))
                    tile.setOriginalMaterial(tileMaterial);
                    tile.getMesh().position.set(i, 0, -j);
                    // FindTile(currentFile, currentRank).getPiece().tile = FindTile(newFile, newRank);
                    board.tilemap[i][j] = tile;
                    game_group.add(tile.getMesh());
                }
            }
            PlacePieces();
            scene.add(game_group);
        }

        //variables to keep the models in memory
        var model_pawn = null;
        var model_knight = null;
        var model_rook = null;
        var model_queen = null;
        var model_king = null;
        var model_bishop = null;

        function loadModels(){
          // the loadObject function works asynchronously using callbacks,
          // we use Promise.all to wait for all the models to load before continuing
          return Promise.all(
              [
                loadObject("./models/model_pawn.stl"),
                loadObject("./models/model_knight.stl"),
                loadObject("./models/model_rook.stl"),
                loadObject("./models/model_queen.stl"),
                loadObject("./models/model_king.stl"),
                loadObject("./models/model_bishop.stl")
              ]
          ).then(function(objects){
              model_pawn = objects[0];
              model_knight = objects[1];
              model_rook = objects[2];
              model_queen = objects[3];
              model_king = objects[4];
              model_bishop = objects[5];
          })
        }
        
        function loadObject(path) {
          // create a new promise that will resolve when the file is completely loaded
          return new Promise(function(resolve,reject){
            loader.load(path, function (geometry) {
              resolve(new THREE.Mesh(geometry, material)); // create a 3d object from the file, and using a placeholder material
             })
          });
        }

        function RankToPos(rank) {
            return --rank;
        }

        function FileToPos(file) {
            let files = ['a','b','c','d','e','f','g','h'];
            return files.indexOf(file);
        }

        function PosToRank(pos) {
            return ++pos;
        }

        function PosToFile(pos) {
            if (pos > 7) pos = 7;
            else if (pos < 0) pos = 0;
            var files = ['a','b','c','d','e','f','g','h'];
            return files[pos];
        }

        function FindTile(file, rank) {
            return board.tilemap[FileToPos(file)][RankToPos(rank)];
        }

        function AddPiece(pos) {
            // Create piece, add to scene, shoudln't need to return anything.
            return;
        }

        // animation loop
        function animate() {
            renderer.render(scene, camera);
            // controls.update();
            requestAnimationFrame(animate);
        }

        function StorePGN(pgn) {
            // "1. e4 Nf6 2. f3 e5" becomes [1., e4, Nf6, 2., f3, e5]
            var moveArray;
            moveArray = pgn.split(/\s+/);
            return moveArray;
        }

        //materials to be reused in the pieces
        var blackPieceMaterial = new THREE.MeshPhongMaterial({ color: new THREE.Color(0x303030) });
        var whitePieceMaterial = new THREE.MeshPhongMaterial({ color: new THREE.Color(0x8f8f8f) });

        function CreatePiece(color, model, name, row, column) {
          // creates a piece cloning the model and set to a position in row, column
          var pieces;
          if (color === 'W') {
            pieces = white_pieces; // set to the list of white's pieces
            pieces[name] = model.clone(); 
            pieces[name].material = whitePieceMaterial; 
            pieces[name].position.set(row, 0, -column); // assign the position 
            game_group.add(pieces[name]);
        } else if (color === 'B') {
            pieces = black_pieces; // set to the list of black's pieces
            pieces[name] = model.clone(); 
            pieces[name].material = blackPieceMaterial; 
            pieces[name].position.set(row, 0, -column); 
            pieces[name].rotation.y = Math.PI; // rotate facing towards whites
            game_group.add(pieces[name]);
          }
          return pieces[name];
        }

        function PlacePieces() {
          // two-loop for assigning each piece in the board
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    let name = pieceMap[7-i][j]; //  get the piece position from the corresponding cell in the board 2d array
                    if (name === "") {
                        continue;
                    }
                    let color = name.charAt(0); // get the color, W or B
                    let piece = name.charAt(1); // get the piece type, P, K, H, T, Q, R
                    let number = name.charAt(2); // get the corresponding identifier number
                    
                    let tile = board.tilemap[j][i];
                    var newPiece;
                    switch (piece) {
                        case 'P':
                            newPiece = new Piece(piece, tile, CreatePiece(color, model_pawn, name, j, i), color);
                            break;
                        case 'K':
                            newPiece = new Piece(piece, tile, CreatePiece(color, model_king, name, j, i), color);
                            break;
                        case 'N':
                            newPiece = new Piece(piece, tile, CreatePiece(color, model_knight, name, j, i), color);
                            break;
                        case 'R':
                            newPiece = new Piece(piece, tile, CreatePiece(color, model_rook, name, j, i), color);
                            break;
                        case 'Q':
                            newPiece = new Piece(piece, tile, CreatePiece(color, model_queen, name, j, i), color);
                            break;
                        case 'B':
                            newPiece = new Piece(piece, tile, CreatePiece(color, model_bishop, name, j, i), color);
                            break;
                    }
                    tile.setPiece(newPiece);
                }
            }
        }

        async function StartGame(pgnArray) {
            let colour = 'W';
            for (var i = 0; i < pgnArray.length-1; i++) {
                // ignore the 1., 2. elements
                if (i % 3 == 0|| i == 0) continue;

                await waitingSpaceKeypress();
                
                DoCommand(pgnArray[i], colour);
                colour = (colour === 'W') ? 'B': 'W';
            }
            TriggerWin(pgnArray[pgnArray.length-1]);
        }
        function waitingSpaceKeypress() {
            return new Promise((resolve) => {
                document.addEventListener("keydown", onKeyHandler);
                function onKeyHandler(e) {
                    if (e.keyCode === 0 || e.keyCode === 32) {
                        document.removeEventListener('keydown', onKeyHandler);
                        PlaySound();
                        resolve();
                    }
                }
            })
        }

        function TriggerWin(winner) {
            let textBox = document.getElementById("TextBox");
            textBox.style.visibility = "visible";
            textBox.style.position = "fixed";
            textBox.style.left = "20%";
            textBox.style.top = "20%";
            if (winner === "1-0") {
                textBox.innerHTML = "Checkmate: White wins";
            }
            else {
                textBox.innerHTML = "Checkmate: Black wins";
            }
        }
        
        var skipTestCheck = true;
        function DoCommand(command, colour) {
            if (skipTestCheck == false) {
                TestCheck();
                skipTestCheck = true;
            }
            // Check Contains (+: Check, #: Checkmate, 0-0-0: Castle Queen, 0-0: Castle King, =: Promote pawn, x: takes)
            if (command.includes('+')) {
                // Handle Check
                DoCheck(colour);
                // Remove '+'
                command = command.replace('+', '');
                // On repeated calls, TestCheck() wont be called, so the check wont be immediately undone.
                skipTestCheck = true;
                // Call CheckCommand again
                DoCommand(command, colour);
                // Calls after will now undo the check
                skipTestCheck = false;
                // Return so that DoBasicCommand() isn't called twice
                return;
            }
            else if (command.includes('#')) {
                // Handle Checkmate
                DoCheck(colour);
                // Remove '#'
                command = command.replace('#', '');
                // Call CheckCommand again
                DoCommand(command, colour);
                // Return
                return;
            }
            
            if (command.includes("O-O-O")) {
                // Handle Castle Queen
                DoCastleQueen(colour);
                // Return
                return;
            }
            else if (command.includes("O-O")) {
                // Handle Castle King
                DoCastleKing(colour);
                // Return
                return;
            }

            if (command.includes('=')) {
                // Handle Promote Pawn
                DoPromotePawn(command, colour);
                // Remove '=' and last char
                command = command.slice(0, command.length - 2);
                // Call CheckCommand again
                DoCommand(command, colour);
                // Return
                return;
            }
            
            if (command.includes('x')) {
                // Handle Takes
                // Remove Piece at pos of last 2 char
                let takenTile = FindTile(command.charAt(command.length - 2), command.charAt(command.length - 1));
                DoTakePiece(colour, takenTile);
                // Remove 'x'
                command = command.replace('x', '');
                // Call CheckCommand again
                DoCommand(command, colour);
                // Return
                return;
            }
            DoBasicCommand(command, colour);
        }

        function TestCheck() {
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    let tempTile = board.tilemap[i][j];
                    if (tempTile.getPiece() == undefined) continue;
                    if (tempTile.getPiece().getType() == 'K') {
                        if (Object.is(tempTile.getMesh().material, checkTileMaterial)) tempTile.getMesh().material = tempTile.getOriginalMaterial();
                    }
                }
            }
        }

        function DoCheck(colour) {
            // return;
            var kingPiece;
            var kingTile;
            let highlightColour = checkTileColour;
            let breakLoop = false;
            if (colour === 'W') {
                // Look for black King tile
                for (let i = 0; i < 8; i++) {
                    if (breakLoop) break;
                    for (let j = 0; j < 8; j++) {
                        if (breakLoop) break;
                        kingPiece = board.tilemap[i][j].getPiece();
                        if (!kingPiece || kingPiece.getType() != 'K' || kingPiece.getColour() != 'B') continue;
                        breakLoop = true;
                    }
                }
                kingTile = kingPiece.getTile();
            }
            else {
                // Look for white King
                for (let i = 0; i < 8; i++) {
                    if (breakLoop) break;
                    for (let j = 0; j < 8; j++) {
                        if (breakLoop) break;
                        kingPiece = board.tilemap[i][j].getPiece();
                        if (!kingPiece || kingPiece.getType() != 'K' || kingPiece.getColour() != 'W') continue;
                        breakLoop = true;
                    }
                }
                kingTile = kingPiece.getTile();
            }
            // Highlight King tile
            kingTile.getMesh().material = checkTileMaterial;
        }

        function DoCastleQueen(colour) {
            var kingPiece;
            var rookPiece;
            // if white
            if (colour === 'W') {
                // Find King
                kingPiece = FindTile('e', 1).piece;
                // Find Rook
                rookPiece = FindTile('a', 1).piece;
                // Move King 2 Left
                MovePiece(kingPiece, 'c', 1);
                // Move Rook 3 Right
                MovePiece(rookPiece, 'd', 1);
            }
            else {
                kingPiece = FindTile('e', 8).piece;
                rookPiece = FindTile('a', 8).piece;
                MovePiece(kingPiece, 'c', 8);
                MovePiece(rookPiece, 'd', 8);
            }
        }
        
        function DoCastleKing(colour) {
            var kingPiece;
            var rookPiece;
            // if white
            if (colour === 'W') {
                // Find King
                kingPiece = FindTile('e', 1).piece;
                // Find Rook
                rookPiece = FindTile('h', 1).piece;
                // Move King 2 Right
                MovePiece(kingPiece, 'g', 1);
                // Move Rook 3 Left
                MovePiece(rookPiece, 'f', 1);
            }
            else {
                kingPiece = FindTile('e', 8).piece;
                rookPiece = FindTile('h', 8).piece;
                MovePiece(kingPiece, 'g', 8);
                MovePiece(rookPiece, 'f', 8);
            }
        }

        function DoPromotePawn(command, colour) {
            let newPieceType = command.charAt(command.length - 1);
            var rank;
            if (colour === 'W') {
                rank = 7;
            }
            else {
                rank = 2;
            }
            let file = command.charAt(0);
            let pawnTile = FindTile(file, rank);
            // Remove Pawn
            scene.remove(pawnTile.piece.mesh);
            // Add new Piece depending on last letter
            AddPiece(newPieceType, rank, file);
        }

        function DoTakePiece(colour, takenTile) {
            // REMOVE THIS WHEN DONE
            // return;
            // Remove piece at takenTile
            // Move it to TakenPieces of same colour
            takenTile.getPiece().getMesh().position.set(3.5,-2,-3.5);
            scene.remove(takenTile.getPiece().getMesh());
            takenTile.setPiece(undefined);
        }

        function DoBasicCommand(command, colour) {
            // endFile/x-axis = 2nd last char
            let endFile = command.charAt(command.length - 2);
            // endRank/y-axis = last char
            let endRank = parseInt(command.charAt(command.length - 1));

            // target = piece to move
            var target;
            var disambiguator;

            // if 2 char -- e4
            if (command.length == 2) {
                let pawnRank = endRank - 1;
                var tempTile;
                // Look for Pawn
                // Set target to Pawn
                if (colour === 'W') {
                    tempTile = FindTile(endFile, endRank - 1);
                    if (tempTile.getPiece() == undefined) tempTile = FindTile(endFile, endRank - 2);
                    target = tempTile.getPiece();
                }
                else {
                    tempTile = FindTile(endFile, endRank + 1);
                    if (tempTile.getPiece() == undefined) tempTile = FindTile(endFile, endRank + 2);
                    target = tempTile.getPiece();
                }
            }
            // if 3 char -- Qe4 / de4
            else if (command.length == 3) {
                // Look for piece of type 1st char
                // Type of piece is specified in first char as UpperCase
                var type = command.charAt(0);
                if (IsUpperCase(type)) {
                    target = LookForPieceToMove(type, colour, endFile, endRank);
                }
                // If type is not UpperCase, type must be pawn and file is specified
                else {
                    disambiguator = command.charAt(0);
                    target = LookForPieceToMove('P', colour, endFile, endRank, disambiguator);
                }
            }
            // if 4 char -- Qde4/Q3e4
            else if (command.length == 4) {
                let type = command.charAt(0);
                // Look for piece of type 1st char on 2nd char rank/file
                disambiguator = command.charAt(1);
                if (!(/[a-h]/).test(disambiguator)) disambiguator = parseInt(disambiguator);

                target = LookForPieceToMove(type, colour, endFile, endRank, disambiguator);
                // If 2nd character is a a-h, find piece on that file
                // if ((/[a-h]/).test(disambiguator)) {
                //     var file = disambiguator;
                // }
                // // Else 2nd character is 1-8. find piece on that rank
                // else {
                //     var rank = disambiguator;
                // }
                // target = LookForPiece(type, colour, endFile, endRank, disambiguator);
            }
            // if 5 char -- Qd3e4
            else {
                // Look for piece at position (2nd, 3rd)
                // Move piece to destination
                var file = command.charAt(1);
                var rank = command.charAt(2);
                target = FindTile(file, rank).getPiece();
            }
            
            MovePiece(target, endFile, endRank);
        }

        function IsUpperCase(str) {
            if (str.toUpperCase() === str) return true;
            return false;
        }

        // This function will always be called with both type paramanter as a single upper-case character eg, "R"
        // and colour paramater as a string, either "white" or "black"
        // Function should return the reference to the piece.
        function LookForPieceToMove(type, colour, endFile, endRank, disambiguator) {
            // if colour.incldes("white") 
            // Look for white piece
            // else
            // look for black piece
            var pieceToReturn;
            let mult = 1;
            let stopN = false;
            let stopNE = false;
            let stopE = false;
            let stopSE = false;
            let stopS = false;
            let stopSW = false;
            let stopW = false;
            let stopNW = false;
            switch (type) {
                // look for king
                case 'K':
                    // from tile, look in every direction once
                    // if you are in bounds, search in that direction for the 
                    if (endRank != 8) pieceToReturn = SearchN(type, colour, endFile, endRank, mult);
                    if (!pieceToReturn && endFile != 'h' && endRank != 8) pieceToReturn = SearchNE(type, colour, endFile, endRank, mult);
                    if (!pieceToReturn && endRank != 8) pieceToReturn = SearchE(type, colour, endFile, endRank, mult);
                    if (!pieceToReturn && endFile != 'h' && endRank != 1) pieceToReturn = SearchSE(type, colour, endFile, endRank, mult);
                    if (!pieceToReturn && endRank != 1) pieceToReturn = SearchS(type, colour, endFile, endRank, mult);
                    if (!pieceToReturn && endFile != 'a' && endRank != 1) pieceToReturn = SearchSW(type, colour, endFile, endRank, mult);
                    if (!pieceToReturn && endFile != 'a') pieceToReturn = SearchW(type, colour, endFile, endRank, mult);
                    if (!pieceToReturn && endFile != 'a' && endRank != 8) pieceToReturn = SearchNW(type, colour, endFile, endRank, mult);    
                    break;
                // look for queen
                case 'Q':
                    // from tile, look N,NE,E,SE,S,SW,W,NW until found
                    while (!pieceToReturn) {

                        if (!stopN && !pieceToReturn && (endRank + mult-1) < 8) pieceToReturn = SearchN(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) {pieceToReturn = undefined; stopN = true;}
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopNE && !pieceToReturn && PosToFile(FileToPos(endFile) + mult-1) != 'h' && (endRank + mult-1) < 8) pieceToReturn = SearchNE(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) {pieceToReturn = undefined; stopNE = true;}
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopE && !pieceToReturn && PosToFile(FileToPos(endFile) + mult-1) != 'h') pieceToReturn = SearchE(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) {pieceToReturn = undefined; stopE = true;}
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopSE && !pieceToReturn && PosToFile(FileToPos(endFile) + mult-1) != 'h' && (endRank - mult+1) > 1) pieceToReturn = SearchSE(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) {pieceToReturn = undefined; stopSE = true;}
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopS && !pieceToReturn && (endRank - mult+1) > 1) pieceToReturn = SearchS(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) {pieceToReturn = undefined; stopS = true;}
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopSW && !pieceToReturn && PosToFile(FileToPos(endFile) - mult+1) != 'a' && (endRank - mult+1) > 1) pieceToReturn = SearchSW(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) {pieceToReturn = undefined; stopSW = true;}
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopW && !pieceToReturn && PosToFile(FileToPos(endFile) - mult+1) != 'a') pieceToReturn = SearchW(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) {pieceToReturn = undefined; stopW = true;}
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopNW && !pieceToReturn && PosToFile(FileToPos(endFile) - mult+1) != 'a' && (endRank + mult-1) < 8) pieceToReturn = SearchNW(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) {pieceToReturn = undefined; stopNW = true;}
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (mult > 7) break;
                        mult++;
                    }

                    break;
                // look for rook
                case 'R':
                    // from tile, look N,E,S,W until found
                    while (!pieceToReturn ) {
                        if (!stopN && !pieceToReturn && (endRank + mult-1) < 8) pieceToReturn = SearchN(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) {pieceToReturn = undefined; stopN = true;}
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopE && !pieceToReturn && PosToFile(FileToPos(endFile) + mult-1) != 'h') pieceToReturn = SearchE(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) {pieceToReturn = undefined; stopE = true;}
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopS && !pieceToReturn && (endRank - mult+1) > 1) pieceToReturn = SearchS(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) {pieceToReturn = undefined; stopS = true;}
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopW && !pieceToReturn && PosToFile(FileToPos(endFile) - mult+1) != 'a') pieceToReturn = SearchW(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) {pieceToReturn = undefined; stopW = true;}
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        mult++;
                    }

                    break;
                // look for bishop
                case 'B':
                    // from tile, look NE,SE,SW,NW
                    while (!pieceToReturn) {
                        if (!stopNE && !pieceToReturn && PosToFile(FileToPos(endFile) + mult-1) != 'h' && (endRank + mult-1) < 8) pieceToReturn = SearchNE(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) {pieceToReturn = undefined; stopNE = true;}
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopSE && !pieceToReturn && PosToFile(FileToPos(endFile) + mult-1) != 'h' && (endRank - mult+1) > 1) pieceToReturn = SearchSE(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) {pieceToReturn = undefined; stopSE = true;}
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopSW && !pieceToReturn && PosToFile(FileToPos(endFile) - mult+1) != 'a' && (endRank - mult+1) > 1) pieceToReturn = SearchSW(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) {pieceToReturn = undefined; stopSW = true;}
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopNW && !pieceToReturn && PosToFile(FileToPos(endFile) - mult+1) != 'a' && (endRank + mult-1) < 8) pieceToReturn = SearchNW(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) {pieceToReturn = undefined; stopNW = true;}
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        mult++;
                    }

                    break;
                // look for knight
                case 'N':
                    // from tile, look in L
                    if (endFile != 'g' && endFile != 'h' && endRank < 8) pieceToReturn = SearchKnight1(type, colour, endFile, endRank, 1);
                    if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                    if (!pieceToReturn && endFile != 'a' && endFile != 'b' && endRank > 1) pieceToReturn = SearchKnight1(type,colour, endFile, endRank, -1);
                    if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                    if (!pieceToReturn && endFile != 'h' && endRank < 7) pieceToReturn = SearchKnight1(type, colour, endFile, endRank, 2);
                    if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                    if (!pieceToReturn && endFile != 'a' && endRank > 2) pieceToReturn = SearchKnight1(type, colour, endFile, endRank, -2);
                    if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                    if (!pieceToReturn && endFile != 'a' && endFile != 'b' && endRank < 8) pieceToReturn = SearchKnight2(type, colour, endFile, endRank, 1);
                    if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                    if (!pieceToReturn && endFile != 'g' && endFile != 'h' && endRank > 1) pieceToReturn = SearchKnight2(type, colour, endFile, endRank, -1);
                    if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                    if (!pieceToReturn && endFile != 'a' && endRank < 7) pieceToReturn = SearchKnight2(type, colour, endFile, endRank, 2);
                    if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                    if (!pieceToReturn && endFile != 'h' && endRank > 2) pieceToReturn = SearchKnight2(type, colour, endFile, endRank, -2);

                    break;
                // look for pawn
                default:
                    // from tile, look above
                    if (colour === 'W') {
                        if (endFile != 'h' && endRank > 1) pieceToReturn = SearchSE(type, colour, endFile, endRank, mult);
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                        if (!pieceToReturn && endFile != 'a' && endRank > 1) pieceToReturn = SearchSW(type, colour, endFile, endRank, mult);
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                    }
                    else {
                        if (endFile != 'h' && endRank < 8) pieceToReturn = SearchNE(type, colour, endFile, endRank, mult);
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                        if (!pieceToReturn && endFile != 'a' && endRank < 8) pieceToReturn = SearchNW(type, colour, endFile, endRank, mult);
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                    }
                    
                    break;
                }

            return pieceToReturn;
        }

        function SearchTile(type, colour, file, rank, fileOffset, rankOffset) {
            let newFile = PosToFile(FileToPos(file) + fileOffset);
            let newRank = rank + rankOffset;
            
            return FindTile(newFile, newRank).getPiece();
        }

        function SearchN(type, colour, endFile, endRank, mult, looped) {
            let tempPiece = SearchTile(type, colour, endFile, endRank, 0*mult, 1*mult);
            if (looped) return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : true;
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        function SearchNE(type, colour, endFile, endRank, mult, looped) {
            let tempPiece = SearchTile(type, colour, endFile, endRank, 1*mult, 1*mult);
            if (looped) return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : true;
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        function SearchE(type, colour, endFile, endRank, mult, looped) {
            let tempPiece = SearchTile(type, colour, endFile, endRank, 1*mult, 0*mult);
            if (looped) return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : true;
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        function SearchSE(type, colour, endFile, endRank, mult, looped) {
            let tempPiece = SearchTile(type, colour, endFile, endRank, 1*mult, -1*mult);
            if (looped) return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : true;
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        function SearchS(type, colour, endFile, endRank, mult, looped) {
            let tempPiece = SearchTile(type, colour, endFile, endRank, 0*mult, -1*mult);
            if (looped) return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : true;
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        function SearchSW(type, colour, endFile, endRank, mult, looped) {
            let tempPiece = SearchTile(type, colour, endFile, endRank, -1*mult, -1*mult);
            if (looped) return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : true;
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        function SearchW(type, colour, endFile, endRank, mult, looped) {
            let tempPiece = SearchTile(type, colour, endFile, endRank, -1*mult, 0*mult);
            if (looped) return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : true;
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        function SearchNW(type, colour, endFile, endRank, mult, looped) {
            let tempPiece = SearchTile(type, colour, endFile, endRank, -1*mult, 1*mult);
            if (looped) return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : true;
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        function SearchKnight1(type, colour, endFile, endRank, mult) {
            let tempPiece = SearchTile(type, colour, endFile, endRank, 2/mult, 1*mult);
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        function SearchKnight2(type, colour, endFile, endRank, mult) {
            let tempPiece = SearchTile(type, colour, endFile, endRank, -2/mult, 1*mult);
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        function CheckDisambiguator(pieceToCheck, disambiguator) {
            if (!pieceToCheck) return true;
            if (!disambiguator) return true;
            return ((pieceToCheck.getTile().getFile() === disambiguator || pieceToCheck.getTile().getRank() === disambiguator)) ? true : false;
        }

        function MovePiece(target, endFile, endRank) {
            // Change the tile that the piece points to.
            // Old tile should dereference the piece.
            // New tile should reference piece.
            // No need to return anything.
            target.getTile().setPiece(undefined);
            target.setTile(FindTile(endFile, endRank));
            target.getTile().setPiece(target);
            target.updatePosition();
        }

        function PlaySound() {
            let path = '/sounds/check.mp3';
            let ele = new Audio(path);
            ele.play();
        }
    </script>
</body>
</html>