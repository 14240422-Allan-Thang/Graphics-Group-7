<html>

<head>
    <title>Chess Project</title>
    <link rel="stylesheet" href="style.css">
</head>

<style>
    body {
        margin: 0;
    }

    canvas {
        width: 100%;
        height: 100%
    }
</style>

<body>
    <script src="js/three.js"> </script>
    <script src="js/OrbitControls.js"> </script>
    <script src="js/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"
        integrity="sha512-WoO4Ih0CDOSLYafy22wZD/mcJ7k0ESLqtQsFa6zFKnEUrbtuGU+GkLtVhgt93xa2qewG5gKEC6CWlN8OaCTSVg=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="js/menu.js"> </script>
    <script src="./js/classes.js"></script>

    <style>
        body {
            font-family: Monospace;
            background-color: #000;
            color: #fff;
            margin: 0px;
            overflow: hidden;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
        }
    </style>

    <div id = "menu" class = "container">

        <div class = "title-header">
            <h1> Games </h1>  
        </div>

        <div class = "play-class">
            <button id="game1" class = "game-button" onclick = "button1()" > Kasparov Vs Topalov (1999) </button>
            <button id="game2" class = "game-button" onclick = "button2()" > Morphy Vs Allies (1858) </button>
            <button id="game3" class = "game-button" onclick = "button3()"> Aronian Vs Anand (2013) </button>
            <button id="game4" class = "game-button" onclick = "button4()"> Karpov Vs Kasparov (1985) </button>
            <button id="game5" class = "game-button" onclick = "button5()"> Byrne Vs Fischer (1956) </button>
            <button id="game6" class = "game-button" onclick = "button6()"> Ivanchuk Vs Yusupov (1991) </button>
            <button id="game7" class = "game-button" onclick = "button7()"> Short Vs Tmman (1991) </button>
            <button id="game8" class = "game-button" onclick = "button8()"> BaiJinshi Vs DingLiren (2017) </button>
            <button id="game9" class = "game-button" onclick = "button9()"> Rotlewi Vs Rubinstein (1997) </button>
            <button id="game10" class = "game-button" onclick = "button10()"> Geller Vs Euwe (1953) </button>    
        </div>
    </div>
    
    <div id="TextBox"></div>

    <div class ="text-instruction">
        <p> 1. Choose a game from the list of previous matches <br>
            2. Playout the entire game played by the players by pressing or holding "Spacebar" <br>
            3. Change the preferred style of the game using controls at top right corner <br>
            4. Reset the whole game using the "reset" button
        </p>
    </div>

    <div class = "button-corner">
        <button id="reset_button" class = "reset-button" onclick= "resetBtn()"> Reset </button>
    </div>

    <script>
        
        /* STRUCTURE OF THE FILE
            KEY GLOBAL VARIALBES
            CORE FUNCTIONS - ANIMATE / INIT / SETUP GAME -> PLAY GAME
            SUB FUNCTIONS - E.G. LOAD MODELS / HANDLE CHECK / PLAY SOUND
            HELPER FUNCTIONS - E.G. CONVERT FILE TO INT / CHECK UPPER CASE
        */

        /* 
            ********************
            KEY GLOBAL VARIABLES
            ********************
        */

        //reload the page
        function resetBtn(){
            location.reload();
        }

        //holds the pieces of each player, whites and blacks
        var black_pieces = {};
        var white_pieces = {};
        let whiteTileColour = new THREE.Color(0xffffff);
        let blackTileColour = new THREE.Color(0x000000);
        let checkTileColour = new THREE.Color(0xd61b1b);

        const textureLoader = new THREE.TextureLoader();
        let pieceTextures = {};

        var scene, camera, renderer;
        let loader = new THREE.GLTFLoader();
        let material = new THREE.MeshPhongMaterial({ color: 0x55B663 });
        var board, game_group;

        var blackPieceMaterial = new THREE.MeshPhongMaterial({ color: new THREE.Color(0x303030) });
        var whitePieceMaterial = new THREE.MeshPhongMaterial({ color: new THREE.Color(0x8f8f8f) });


        var blackTileMaterial = new THREE.MeshStandardMaterial({
            color: new THREE.Color(0x303030),
        });


        var whiteTileMaterial = new THREE.MeshStandardMaterial({
            color: new THREE.Color(0x8f8f8f),
        });

        //variables to keep the models in memory
        var model_pawn = null;
        var model_knight = null;
        var model_rook = null;
        var model_queen = null;
        var model_king = null;
        var model_bishop = null;


        /* StorePGN should write the proper pieces in the array board with the format of "BP0" for black pawn 0 */
        /* 
            B for black, W for white,
            R for rook, K for knight, B for bishop, K for king, Q for queen, P for pawn
            0 .. 7 the number of the pieces which are duplicated in each color,
            0 for the ones on the left hand, 1 for the ones on  the right hand, 
        */
        let pieceMap = [
            ["BR0", "BN0", "BB0", "BQ", "BK", "BB1", "BN1", "BR1"],
            ["BP0", "BP1", "BP2", "BP3", "BP4", "BP5", "BP6", "BP7"],
            ["", "", "", "", "", "", "", ""],
            ["", "", "", "", "", "", "", ""],
            ["", "", "", "", "", "", "", ""],
            ["", "", "", "", "", "", "", ""],
            ["WP0", "WP1", "WP2", "WP3", "WP4", "WP5", "WP6", "WP7"],
            ["WR0", "WN0", "WB0", "WQ", "WK", "WB1", "WN1", "WR1"]
        ];

        /* Allan
            Board doesn't need to be a class beacuse it is just a 2d array to hold the tiles.
        */
        const Board = {
            tilemap: [],
        };

        board = Board;
        board.tilemap = new Array(8);
        for (let i = 0; i < 8; i++) {
            board.tilemap[i] = new Array(8);
        }

        class ColorGUIHelper {
            constructor(object, prop) {
                this.object = object;
                this.prop = prop;
            }
            get value() {
                return `#${this.object[this.prop].getHexString()}`;
            }
            set value(hexString) {
                this.object[this.prop].set(hexString);
            }
        }

        /* 
            **********************************
                      CORE FUNCTIONS
            **********************************
        */

        //make the script wait until all the pieces are loaded before initializing the game and rendering
        loadModels().then(
            function () {
                init();
                animate();
            }
        );
        
        // animation loop
        function animate() {
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        function init() {
            // scene
            scene = new THREE.Scene();

            // renderer
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // camera
            var ratio = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(45, ratio, 0.1, 1000);
            camera.position.set(3.5, 10, 3); //initial position of the camera
            camera.lookAt(3.5, 0, -3.5);
            camera.lookAt(3.5, 0, -3.5);
            camera.updateProjectionMatrix();

            // resize
            window.addEventListener('resize', function () {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            });

            // ambient light
            const color = 0xFFFFFF;
            const intensity = 1;
            const light = new THREE.AmbientLight(color, intensity);
            scene.add(new THREE.AmbientLight(0x404040));
            scene.add(light);

            // directional light
            const dl = new THREE.DirectionalLight(0xffffff, 0.5);
            dl.position.set(0, 2, 2);
            scene.add(dl);

            // gui
            const gui = new dat.GUI();

            var temp;
            var data = {
                background: "Select"
                
            }

            // light intensity slider
            const folderlight = gui.addFolder("Light");
            folderlight.add(light, 'intensity', 0, 2, 0.1);
            folderlight.add(dl.position, 'y', 0.1, 5, 0.1);

            // color slider
            const folderpieces = gui.addFolder("Pieces");

            folderpieces.addColor(new ColorGUIHelper(whitePieceMaterial, 'color'), 'value').name('WhitePiece');
            folderpieces.addColor(new ColorGUIHelper(blackPieceMaterial, 'color'), 'value').name('BlackPiece');

            const folderboard = gui.addFolder("Board");
            folderboard.addColor(new ColorGUIHelper(blackTileMaterial, 'color'), 'value').name('BlackTile');
            folderboard.addColor(new ColorGUIHelper(whiteTileMaterial, 'color'), 'value').name('WhiteTile');


            const folderbackground = gui.addFolder("Skybox");
            var selectedSkybox = folderbackground.add(data, 'background', ['Select','Cloudy', 'Interstellar', 'Space', 'Sunset']).name("Skybox");

            selectedSkybox.onChange(function(temp){
                addSkybox(temp);
            });


            const folderTextures = gui.addFolder("Textures");

            folderTextures.add(blackPieceMaterial, 'map', Object.keys(pieceTextures)).name('Black Piece').onChange((value) => {

                blackPieceMaterial.map = pieceTextures[value].color;
                blackPieceMaterial.needsUpdate = true;
            });
            folderTextures.add(whitePieceMaterial, 'map', Object.keys(pieceTextures)).name('White Piece').onChange((value) => {

                whitePieceMaterial.map = pieceTextures[value].color;
                whitePieceMaterial.needsUpdate = true;
            });
            folderTextures.add(blackTileMaterial, 'map', Object.keys(pieceTextures)).name('Black Square').onChange((value) => {

                blackTileMaterial.map = pieceTextures[value].color;
                blackTileMaterial.needsUpdate = true;
            });
            folderTextures.add(whiteTileMaterial, 'map', Object.keys(pieceTextures)).name('White Square').onChange((value) => {

                whiteTileMaterial.map = pieceTextures[value].color;
                whiteTileMaterial.needsUpdate = true;
            });

            CreateBoard();
        }

        /* Allan
            Creating tiles and adding them to the board 2d array and scene.
        */
        var tileGeometry = new THREE.BoxGeometry(1, 0.1, 1);
        function CreateBoard() {

            game_group = new THREE.Group();

            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    let tile = new Tile(PosToFile(i), PosToRank(j));
                    var tileColour;
                    var tileMaterial;
                    if (j % 2) {
                        if (i % 2) {
                            tileColour = 'B';
                            tileMaterial = blackTileMaterial;
                        } else {
                            tileColour = 'W';
                            tileMaterial = whiteTileMaterial;
                        }
                    } else {
                        if (i % 2) {
                            tileColour = 'W';
                            tileMaterial = whiteTileMaterial;
                            tile.setColour(whiteTileColour);
                        } else {
                            tileColour = 'B';
                            tileMaterial = blackTileMaterial;
                        }
                    }
                    tile.setColour(tileColour);
                    tile.setMesh(new THREE.Mesh(tileGeometry, tileMaterial))
                    tile.setOriginalMaterial(tileMaterial);
                    tile.getMesh().position.set(i, 0, -j);
                    board.tilemap[i][j] = tile;
                    game_group.add(tile.getMesh());
                }
            }
            PlacePieces();
            scene.add(game_group);
        }

        function PlacePieces() {
            // two-loop for assigning each piece in the board
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    let name = pieceMap[7 - i][j]; //  get the piece position from the corresponding cell in the board 2d array
                    if (name === "") {
                        continue;
                    }
                    let color = name.charAt(0); // get the color, W or B
                    let piece = name.charAt(1); // get the piece type, P, K, H, T, Q, R
                    let number = name.charAt(2); // get the corresponding identifier number

                    let tile = board.tilemap[j][i];
                    var newPiece;
                    switch (piece) {
                        case 'P':
                            newPiece = new Piece(piece, tile, CreatePiece(color, model_pawn, name, j, i), color);
                            break;
                        case 'K':
                            newPiece = new Piece(piece, tile, CreatePiece(color, model_king, name, j, i), color);
                            break;
                        case 'N':
                            newPiece = new Piece(piece, tile, CreatePiece(color, model_knight, name, j, i), color);
                            break;
                        case 'R':
                            newPiece = new Piece(piece, tile, CreatePiece(color, model_rook, name, j, i), color);
                            break;
                        case 'Q':
                            newPiece = new Piece(piece, tile, CreatePiece(color, model_queen, name, j, i), color);
                            break;
                        case 'B':
                            newPiece = new Piece(piece, tile, CreatePiece(color, model_bishop, name, j, i), color);
                            break;
                    }
                    tile.setPiece(newPiece);
                }
            }
        }

        // Allan
        async function StartGame(pgnArray) {
            // Start with white's move
            let colour = 'W';
            for (var i = 0; i < pgnArray.length - 1; i++) {
                // ignore the '1.', '2.' elements
                if (i % 3 == 0 || i == 0) continue;

                await waitingSpaceKeypress();

                // Do command after space is pressed, then switch colours for other's turn.
                DoCommand(pgnArray[i], colour);
                colour = (colour === 'W') ? 'B' : 'W';
            }
            TriggerWin(pgnArray[pgnArray.length - 1]);
        }
        function waitingSpaceKeypress() { // Play sound on Spacebar press.
            return new Promise((resolve) => {
                document.addEventListener("keydown", onKeyHandler);
                function onKeyHandler(e) {
                    if (e.keyCode === 0 || e.keyCode === 32) {
                        document.removeEventListener('keydown', onKeyHandler);
                        PlaySound();
                        resolve();
                    }
                }
            })
        }

        /* Allan
            Handle special commands. Do the special command, then remove characters
            from command string before passing it to another function to do the basic command.
            Read each Do*() function for how they are handled.
        */
        var skipTestCheck = true;
        function DoCommand(command, colour) {
            // If a Check occured last turn, undo the check highlighting.
            if (skipTestCheck == false) {
                TestCheck();
                skipTestCheck = true;
            }
            // Check if command contains (+: Check, #: Checkmate, 0-0-0: Castle Queen, 0-0: Castle King, =: Promote pawn, x: takes)
            if (command.includes('+')) {
                // Handle Check
                DoCheck(colour);
                // Remove '+'
                command = command.replace('+', '');
                // On repeated calls, TestCheck() wont be called, so the check wont be immediately undone.
                skipTestCheck = true;
                // Call CheckCommand again
                DoCommand(command, colour);
                // Calls after will now undo the check
                skipTestCheck = false;
                // Return so that DoBasicCommand() isn't called twice
                return;
            }
            else if (command.includes('#')) {
                DoCheck(colour);
                command = command.replace('#', '');
                DoCommand(command, colour);
                return;
            }

            if (command.includes("O-O-O")) {
                DoCastleQueen(colour);
                return;
            }
            else if (command.includes("O-O")) {
                DoCastleKing(colour);
                return;
            }

            if (command.includes('=')) {
                DoPromotePawn(command, colour);
                // Remove '=' and last char
                command = command.slice(0, command.length - 2);
                DoCommand(command, colour);
                return;
            }

            if (command.includes('x')) {
                // Remove Piece at pos of last 2 char
                let takenPiece = FindTile(command.charAt(command.length - 2), command.charAt(command.length - 1)).getPiece();
                DoTakePiece(takenPiece);
                command = command.replace('x', '');
                DoCommand(command, colour);
                return;
            }
            DoBasicCommand(command, colour);
        }

        function DoBasicCommand(command, colour) {
            // endFile/x-axis = 2nd last char
            let endFile = command.charAt(command.length - 2);
            // endRank/y-axis = last char
            let endRank = parseInt(command.charAt(command.length - 1));

            // target = piece to move
            var target;
            var disambiguator;

            // if 2 char -- e4
            if (command.length == 2) {
                let pawnRank = endRank - 1;
                var tempTile;
                // Look for Pawn
                // Set target to Pawn
                if (colour === 'W') {
                    tempTile = FindTile(endFile, endRank - 1);
                    if (tempTile.getPiece() == undefined) tempTile = FindTile(endFile, endRank - 2);
                    target = tempTile.getPiece();
                }
                else {
                    tempTile = FindTile(endFile, endRank + 1);
                    if (tempTile.getPiece() == undefined) tempTile = FindTile(endFile, endRank + 2);
                    target = tempTile.getPiece();
                }
            }
            // if 3 char -- Qe4 / de4
            else if (command.length == 3) {
                // Look for piece of type 1st char
                // Type of piece is specified in first char as UpperCase
                var type = command.charAt(0);
                if (IsUpperCase(type)) {
                    target = LookForPieceToMove(type, colour, endFile, endRank);
                }
                // If type is not UpperCase, type must be pawn and file is specified
                else {
                    var pawnTile;
                    if (colour === 'W') {
                        target = FindTile(type, endRank-1).getPiece();
                    }
                    else target = FindTile(type, endRank+1).getPiece();
                }
            }
            // if 4 char -- Qde4/Q3e4
            else if (command.length == 4) {
                let type = command.charAt(0);
                // Look for piece of type 1st char on 2nd char rank/file
                disambiguator = command.charAt(1);
                if (!(/[a-h]/).test(disambiguator)) disambiguator = parseInt(disambiguator);

                target = LookForPieceToMove(type, colour, endFile, endRank, disambiguator);
            }
            // if 5 char -- Qd3e4
            else {
                // Look for piece at position (2nd, 3rd)
                // Move piece to destination
                var file = command.charAt(1);
                var rank = command.charAt(2);
                target = FindTile(file, rank).getPiece();
            }

            MovePiece(target, endFile, endRank);
        }

        function MovePiece(target, endFile, endRank) {
            // Old tile should dereference the piece.
            target.getTile().setPiece(undefined);
            // Change the tile that the piece points to.
            target.setTile(FindTile(endFile, endRank));
            // New tile should reference piece.
            target.getTile().setPiece(target);
            target.updatePosition();
        }

        /* 
            **********************************
                       SUB FUNCTIONS
            **********************************
        */
        
        function loadModels() {
            return new Promise(
                (ok, no) => {
                    const loader = new THREE.GLTFLoader();
                    loader.load("./models/chess_complete.glb",
                        (gltf) => {
                            model_board = gltf.scene.getObjectByName("BOARD");
                            model_pawn = gltf.scene.getObjectByName("PAWN");
                            model_knight = gltf.scene.getObjectByName("KNIGHT");
                            model_rook = gltf.scene.getObjectByName("ROOK");
                            model_king = gltf.scene.getObjectByName("QUEEN");
                            model_queen = gltf.scene.getObjectByName("KING");
                            model_bishop = gltf.scene.getObjectByName("BISHOP");


                            ok()
                        }
                    );
                    loadTextureSet("Rock");
                    loadTextureSet("Glass");
                    loadTextureSet("Marble");
                    loadTextureSet("Wood");
                }

            );
        }

        function CreatePiece(color, model, name, row, column) {
            // creates a piece cloning the model and set to a position in row, column
            var pieces;
            if (color === 'W') {
                pieces = white_pieces; // set to the list of white's pieces
                pieces[name] = model.clone();
                pieces[name].material = whitePieceMaterial;
                pieces[name].position.set(row, 0, -column); // assign the position 
                game_group.add(pieces[name]);
            } else if (color === 'B') {
                pieces = black_pieces; // set to the list of black's pieces
                pieces[name] = model.clone();
                pieces[name].material = blackPieceMaterial;
                pieces[name].position.set(row, 0, -column);
                pieces[name].rotation.y = Math.PI; // rotate facing towards whites
                game_group.add(pieces[name]);
            }
            return pieces[name];
        }

        function loadTextureSet(folder) {
            let color = textureLoader.load(`Textures/${folder}/basecolor.jpg`);
            color.wrapS = color.wrapT = THREE.RepeatWrapping;
            pieceTextures[folder] = {};
            pieceTextures[folder].color = color;
        }

        //loading skyboxes to the scene
        function addSkybox(selectSkybox)
        {
            const loader = new THREE.CubeTextureLoader();
            switch (selectSkybox){
                case "Cloudy":
                    var skybox = loader.load([
                        'Skybox/Cloudy/bluecloud_bk.jpg',
                        'Skybox/Cloudy/bluecloud_dn.jpg',
                        'Skybox/Cloudy/bluecloud_ft.jpg',
                        'Skybox/Cloudy/bluecloud_lf.jpg',
                        'Skybox/Cloudy/bluecloud_rt.jpg',
                        'Skybox/Cloudy/bluecloud_up.jpg'
                    ]);
                    break;
                
                case 'Interstellar':
                    var skybox = loader.load([
                        'Skybox/Interstellar/interstellar_bk.png',
                        'Skybox/Interstellar/interstellar_dn.png',
                        'Skybox/Interstellar/interstellar_ft.png',
                        'Skybox/Interstellar/interstellar_lf.png',
                        'Skybox/Interstellar/interstellar_rt.png',
                        'Skybox/Interstellar/interstellar_up.png'
                    ]);
                    break;
                case 'Space':
                    var skybox = loader.load([
                        'Skybox/Space/space_bk.png',
                        'Skybox/Space/space_dn.png',
                        'Skybox/Space/space_ft.png',
                        'Skybox/Space/space_lf.png',
                        'Skybox/Space/space_rt.png',
                        'Skybox/Space/space_up.png'
                    ]);
                    break;
                case 'Sunset':
                    var skybox = loader.load([
                        'Skybox/Sunset/yellowcloud_bk.jpg',
                        'Skybox/Sunset/yellowcloud_dn.jpg',
                        'Skybox/Sunset/yellowcloud_ft.jpg',
                        'Skybox/Sunset/yellowcloud_lf.jpg',
                        'Skybox/Sunset/yellowcloud_rt.jpg',
                        'Skybox/Sunset/yellowcloud_up.jpg'
                    ]);
                    break;
            }

            scene.background = skybox;
        }
        
        /* Allan
            This function checks to see if any tile that is occupied by a King piece
            is highlighted and changes it back to its original colour.
        */
        var checkTileMaterial = new THREE.MeshBasicMaterial({ color: checkTileColour });
        function TestCheck() {
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    let tempTile = board.tilemap[i][j];
                    if (tempTile.getPiece() == undefined) continue;
                    if (tempTile.getPiece().getType() == 'K') {
                        if (Object.is(tempTile.getMesh().material, checkTileMaterial)) tempTile.getMesh().material = tempTile.getOriginalMaterial();
                    }
                }
            }
        }

        /* Allan
            Loop to find the King piece of the opposite colour,
            then break out of the loop once found and get the tile
            it is on.
            Change the material of the tile mesh to a red colour.
        */
        function DoCheck(colour) {
            // return;
            var kingPiece;
            var kingTile;
            let highlightColour = checkTileColour;
            let breakLoop = false;
            if (colour === 'W') {
                // Look for black King tile
                for (let i = 0; i < 8; i++) {
                    if (breakLoop) break;
                    for (let j = 0; j < 8; j++) {
                        if (breakLoop) break;
                        kingPiece = board.tilemap[i][j].getPiece();
                        if (!kingPiece || kingPiece.getType() != 'K' || kingPiece.getColour() != 'B') continue;
                        breakLoop = true;
                    }
                }
                kingTile = kingPiece.getTile();
            }
            else {
                // Look for white King
                for (let i = 0; i < 8; i++) {
                    if (breakLoop) break;
                    for (let j = 0; j < 8; j++) {
                        if (breakLoop) break;
                        kingPiece = board.tilemap[i][j].getPiece();
                        if (!kingPiece || kingPiece.getType() != 'K' || kingPiece.getColour() != 'W') continue;
                        breakLoop = true;
                    }
                }
                kingTile = kingPiece.getTile();
            }
            // Highlight King tile
            kingTile.getMesh().material = checkTileMaterial;
        }

        /* Allan
            Castles can only happen if both the King and Rook haven't moved.
            so their position is always the same.
            Look for the 2 tiles they must be on and move them accordingly.
        */
        function DoCastleQueen(colour) {
            var kingPiece;
            var rookPiece;
            // if white
            if (colour === 'W') {
                // Find King
                kingPiece = FindTile('e', 1).piece;
                // Find Rook
                rookPiece = FindTile('a', 1).piece;
                // Move King 2 Left
                MovePiece(kingPiece, 'c', 1);
                // Move Rook 3 Right
                MovePiece(rookPiece, 'd', 1);
            }
            else {
                kingPiece = FindTile('e', 8).piece;
                rookPiece = FindTile('a', 8).piece;
                MovePiece(kingPiece, 'c', 8);
                MovePiece(rookPiece, 'd', 8);
            }
        }

        function DoCastleKing(colour) {
            var kingPiece;
            var rookPiece;
            // if white
            if (colour === 'W') {
                // Find King
                kingPiece = FindTile('e', 1).piece;
                // Find Rook
                rookPiece = FindTile('h', 1).piece;
                // Move King 2 Right
                MovePiece(kingPiece, 'g', 1);
                // Move Rook 3 Left
                MovePiece(rookPiece, 'f', 1);
            }
            else {
                kingPiece = FindTile('e', 8).piece;
                rookPiece = FindTile('h', 8).piece;
                MovePiece(kingPiece, 'g', 8);
                MovePiece(rookPiece, 'f', 8);
            }
        }

        /* Allan
            Since pawns only promote once they reach the end (rank 1 or 8)
            and pawns must move forwards, the pawn must be on rank 2 if black
            and rank 7 if white.

            A pawn can move forward to promote (e.g. e8) or take a piece
            to promote (e.g. fe8 after DoCommand()).
            Either way, the file that they are on before moving is always the
            first character.

            Remove the pawn's mesh from the group and thus scene.
            Then replace the tile's piece with a new piece based on the new type.
            CreatePiece() set's the tile reference of the piece, so it doesn't need
            to be set separately.
        */
        function DoPromotePawn(command, colour) {
            let newPieceType = command.charAt(command.length - 1);
            var rank;
            if (colour === 'W') {
                rank = 7;
            }
            else {
                rank = 2;
            }
            let file = command.charAt(0);
            let pawnTile = FindTile(file, rank);
            // Remove Pawn
            game_group.remove(pawnTile.getPiece().getMesh());
            // Add new Piece depending on last letter
            var model;
            switch (newPieceType) {
                case 'Q':
                    model = model_queen;
                    break;
                case 'N':
                    model = model_knight;
                    break;
                case 'B':    
                    model = model_bishop;
                    break;
                default:
                    model = model_rook;
                    break;
            }
            pawnTile.setPiece(new Piece(newPieceType, pawnTile, CreatePiece(colour, model, '', pawnTile.getFile(), rank), colour));
        }

        var whiteTakenPieces = new TakenPieces('W');
        var blackTakenPieces = new TakenPieces('B');
        function DoTakePiece(takenPiece) {
            // Remove piece at takenTile
            // Move it to TakenPieces of same colour
            if (takenPiece.colour === 'W') {
                whiteTakenPieces.addPiece(takenPiece);
            }
            else {
                blackTakenPieces.addPiece(takenPiece);
            }
        }

        /* Allan
            This function will always be called with both type paramanter as a single upper-case character eg, "R"
            and colour paramater as a string, either "W" or "B"
            Function returns the reference to the piece.
            This is explained in the presentation.
            Uses a lot of boolean expressions to search for pieces in tiles, while staying in bounds.
            Then the piece found will be tested against the disambiguator if one is specified.
            Search functions are in the HELPER FUNCTIONS part.
        */
        function LookForPieceToMove(type, colour, endFile, endRank, disambiguator) {
            var pieceToReturn;
            let mult = 1;
            let stopN = false;
            let stopNE = false;
            let stopE = false;
            let stopSE = false;
            let stopS = false;
            let stopSW = false;
            let stopW = false;
            let stopNW = false;
            switch (type) {
                // look for king
                case 'K':
                    // from tile, look in every direction once
                    // if you are in bounds, search in that direction for the 
                    if (endRank != 8) pieceToReturn = SearchN(type, colour, endFile, endRank, mult);
                    if (!pieceToReturn && endFile != 'h' && endRank != 8) pieceToReturn = SearchNE(type, colour, endFile, endRank, mult);
                    if (!pieceToReturn && endFile != 'h') pieceToReturn = SearchE(type, colour, endFile, endRank, mult);
                    if (!pieceToReturn && endFile != 'h' && endRank != 1) pieceToReturn = SearchSE(type, colour, endFile, endRank, mult);
                    if (!pieceToReturn && endRank != 1) pieceToReturn = SearchS(type, colour, endFile, endRank, mult);
                    if (!pieceToReturn && endFile != 'a' && endRank != 1) pieceToReturn = SearchSW(type, colour, endFile, endRank, mult);
                    if (!pieceToReturn && endFile != 'a') pieceToReturn = SearchW(type, colour, endFile, endRank, mult);
                    if (!pieceToReturn && endFile != 'a' && endRank != 8) pieceToReturn = SearchNW(type, colour, endFile, endRank, mult);
                    break;
                // look for queen
                case 'Q':
                    // from tile, look N,NE,E,SE,S,SW,W,NW until found
                    while (!pieceToReturn) {

                        if (!stopN && !pieceToReturn && (endRank + mult - 1) < 8) pieceToReturn = SearchN(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopN = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopNE && !pieceToReturn && PosToFile(FileToPos(endFile) + mult - 1) != 'h' && (endRank + mult - 1) < 8) pieceToReturn = SearchNE(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopNE = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopE && !pieceToReturn && PosToFile(FileToPos(endFile) + mult - 1) != 'h') pieceToReturn = SearchE(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopE = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopSE && !pieceToReturn && PosToFile(FileToPos(endFile) + mult - 1) != 'h' && (endRank - mult + 1) > 1) pieceToReturn = SearchSE(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopSE = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopS && !pieceToReturn && (endRank - mult + 1) > 1) pieceToReturn = SearchS(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopS = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopSW && !pieceToReturn && PosToFile(FileToPos(endFile) - mult + 1) != 'a' && (endRank - mult + 1) > 1) pieceToReturn = SearchSW(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopSW = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopW && !pieceToReturn && PosToFile(FileToPos(endFile) - mult + 1) != 'a') pieceToReturn = SearchW(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopW = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopNW && !pieceToReturn && PosToFile(FileToPos(endFile) - mult + 1) != 'a' && (endRank + mult - 1) < 8) pieceToReturn = SearchNW(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopNW = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (mult > 7) break;
                        mult++;
                    }

                    break;
                // look for rook
                case 'R':
                    // from tile, look N,E,S,W until found
                    while (!pieceToReturn) {
                        if (!stopN && !pieceToReturn && (endRank + mult - 1) < 8) pieceToReturn = SearchN(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopN = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopE && !pieceToReturn && PosToFile(FileToPos(endFile) + mult - 1) != 'h') pieceToReturn = SearchE(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopE = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopS && !pieceToReturn && (endRank - mult + 1) > 1) pieceToReturn = SearchS(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopS = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopW && !pieceToReturn && PosToFile(FileToPos(endFile) - mult + 1) != 'a') pieceToReturn = SearchW(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopW = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        mult++;
                    }

                    break;
                // look for bishop
                case 'B':
                    // from tile, look NE,SE,SW,NW
                    while (!pieceToReturn) {
                        if (!stopNE && !pieceToReturn && PosToFile(FileToPos(endFile) + mult - 1) != 'h' && (endRank + mult - 1) < 8) pieceToReturn = SearchNE(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopNE = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopSE && !pieceToReturn && PosToFile(FileToPos(endFile) + mult - 1) != 'h' && (endRank - mult + 1) > 1) pieceToReturn = SearchSE(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopSE = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopSW && !pieceToReturn && PosToFile(FileToPos(endFile) - mult + 1) != 'a' && (endRank - mult + 1) > 1) pieceToReturn = SearchSW(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopSW = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        if (!stopNW && !pieceToReturn && PosToFile(FileToPos(endFile) - mult + 1) != 'a' && (endRank + mult - 1) < 8) pieceToReturn = SearchNW(type, colour, endFile, endRank, mult, true);
                        if (pieceToReturn == true) { pieceToReturn = undefined; stopNW = true; }
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                        mult++;
                    }

                    break;
                // look for knight
                case 'N':
                    // from tile, look in L
                    if (endFile != 'g' && endFile != 'h' && endRank < 8) pieceToReturn = SearchKnight1(type, colour, endFile, endRank, 1);
                    if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                    if (!pieceToReturn && endFile != 'a' && endFile != 'b' && endRank > 1) pieceToReturn = SearchKnight1(type, colour, endFile, endRank, -1);
                    if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                    if (!pieceToReturn && endFile != 'h' && endRank < 7) pieceToReturn = SearchKnight1(type, colour, endFile, endRank, 2);
                    if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                    if (!pieceToReturn && endFile != 'a' && endRank > 2) pieceToReturn = SearchKnight1(type, colour, endFile, endRank, -2);
                    if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;

                    if (!pieceToReturn && endFile != 'a' && endFile != 'b' && endRank < 8) pieceToReturn = SearchKnight2(type, colour, endFile, endRank, 1);
                    if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                    if (!pieceToReturn && endFile != 'g' && endFile != 'h' && endRank > 1) pieceToReturn = SearchKnight2(type, colour, endFile, endRank, -1);
                    if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                    if (!pieceToReturn && endFile != 'a' && endRank < 7) pieceToReturn = SearchKnight2(type, colour, endFile, endRank, 2);
                    if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                    if (!pieceToReturn && endFile != 'h' && endRank > 2) pieceToReturn = SearchKnight2(type, colour, endFile, endRank, -2);

                    break;
                // look for pawn
                default:
                    // from tile, look above
                    if (colour === 'W') {
                        if (endFile != 'h' && endRank > 1) pieceToReturn = SearchSE(type, colour, endFile, endRank, mult);
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                        if (!pieceToReturn && endFile != 'a' && endRank > 1) pieceToReturn = SearchSW(type, colour, endFile, endRank, mult);
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                    }
                    else {
                        if (endFile != 'h' && endRank < 8) pieceToReturn = SearchNE(type, colour, endFile, endRank, mult);
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                        if (!pieceToReturn && endFile != 'a' && endRank < 8) pieceToReturn = SearchNW(type, colour, endFile, endRank, mult);
                        if (!CheckDisambiguator(pieceToReturn, disambiguator)) pieceToReturn = undefined;
                    }

                    break;
            }

            return pieceToReturn;
        }

        /* Allan
            The Checkmate text is revealed when the game ends
            and the text is generated based on the last element in the PGN array.
        */
        function TriggerWin(winner) {
            let textBox = document.getElementById("TextBox");
            textBox.style.visibility = "visible";
            if (winner === "1-0") {
                textBox.innerHTML = "Checkmate: White wins";
            }
            else {
                textBox.innerHTML = "Checkmate: Black wins";
            }
        }
        
        /* 
            **********************************
                    HELPER FUNCTIONS
            **********************************
        */

        /* Allan
            Files are characters a-h, so I created helper functions to
            be able to go left and right.
            Ranks are integers, but functions are added for consistency's sake.
        */
        function RankToPos(rank) {
            return --rank;
        }

        function FileToPos(file) {
            let files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            return files.indexOf(file);
        }

        function PosToRank(pos) {
            return ++pos;
        }

        function PosToFile(pos) {
            if (pos > 7) pos = 7;
            else if (pos < 0) pos = 0;
            var files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            return files[pos];
        }

        /* Allan
            FindTile returns the tile on a given file and rank.
        */
        function FindTile(file, rank) {
            return board.tilemap[FileToPos(file)][RankToPos(rank)];
        }

        // Check if a string is upper-case
        function IsUpperCase(str) {
            if (str.toUpperCase() === str) return true;
            return false;
        }

        /* Allan
            Returns the piece on a tile based on parameters.
            Takes the file and rank and adds the offset.
        */
        function SearchTile(file, rank, fileOffset, rankOffset) {
            let newFile = PosToFile(FileToPos(file) + fileOffset);
            let newRank = rank + rankOffset;

            return FindTile(newFile, newRank).getPiece();
        }

        /* Allan
            Search*() functions are all the same, but with modified offsets.
            The offset depends on which direction is being searched. 
            e.g. Search N will offset by (0,1) to go up.

            Then the offset is multiplied by 'mult', which is passed through
            based on which loop the parent loop is on.
            i.e. mult = 2 means search the second tile.

            The looped paramenter is a boolean that determines if the function
            is being used multiple times. e.g. for bishop/rook/queen
            
            The function returns the piece in that searched tile if 
            the piece has a matching type and colour. 
            
            Otherwise it returns undefined and the loop continues.
            "!tempPiece ||" is added so that the if statement doesn't cause
            an error on .getType() if there was no piece. This will also return undefined
            if true.

            In the case that looped is true, the function returns true instead on undefined
            on a false evaluation. The parent function takes this to mean that a piece
            was found, but wasn't the correct piece, so it will stop using the function
            to search in that direction.
        */
        function SearchN(type, colour, endFile, endRank, mult, looped) {
            let tempPiece = SearchTile(endFile, endRank, 0 * mult, 1 * mult);
            if (looped) return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : true;
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        function SearchNE(type, colour, endFile, endRank, mult, looped) {
            let tempPiece = SearchTile(endFile, endRank, 1 * mult, 1 * mult);
            if (looped) return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : true;
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        function SearchE(type, colour, endFile, endRank, mult, looped) {
            let tempPiece = SearchTile(endFile, endRank, 1 * mult, 0 * mult);
            if (looped) return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : true;
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        function SearchSE(type, colour, endFile, endRank, mult, looped) {
            let tempPiece = SearchTile(endFile, endRank, 1 * mult, -1 * mult);
            if (looped) return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : true;
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        function SearchS(type, colour, endFile, endRank, mult, looped) {
            let tempPiece = SearchTile(endFile, endRank, 0 * mult, -1 * mult);
            if (looped) return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : true;
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        function SearchSW(type, colour, endFile, endRank, mult, looped) {
            let tempPiece = SearchTile(endFile, endRank, -1 * mult, -1 * mult);
            if (looped) return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : true;
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        function SearchW(type, colour, endFile, endRank, mult, looped) {
            let tempPiece = SearchTile(endFile, endRank, -1 * mult, 0 * mult);
            if (looped) return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : true;
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        function SearchNW(type, colour, endFile, endRank, mult, looped) {
            let tempPiece = SearchTile(endFile, endRank, -1 * mult, 1 * mult);
            if (looped) return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : true;
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        /* Allan
            SearchKnight is different since knights move differently.
            This will instead search the tile in an L-shape.
            Both function are called 4 times with a mult of 1,2,-1, and -2
            This way the functions covers all 16 tiles a Knight could be on.
        */
        function SearchKnight1(type, colour, endFile, endRank, mult) {
            let tempPiece = SearchTile(endFile, endRank, 2 / mult, 1 * mult);
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        function SearchKnight2(type, colour, endFile, endRank, mult) {
            let tempPiece = SearchTile(endFile, endRank, -2 / mult, 1 * mult);
            return (!tempPiece || tempPiece.getType() === type && tempPiece.getColour() === colour) ? tempPiece : undefined;
        }

        /* Allan
            This function will check if a piece matches the disabiguator
            It first checks to see if the piece to check and disambiguator exists
            and returns true if it doesn't since it is correct if no disambiguator is
            specified and an undefined piece cannot be checked.

            Then it will check if the piece's tile has the same file or rank as the disambiguator.
        */
        function CheckDisambiguator(pieceToCheck, disambiguator) {
            if (!pieceToCheck) return true;
            if (!disambiguator) return true;
            return ((pieceToCheck.getTile().getFile() === disambiguator || pieceToCheck.getTile().getRank() === disambiguator)) ? true : false;
        }

        /* Allan
            I couldn't get all the sounds to work as apparently sounds can only 
            be played when the user interacts with the website
            e.g. pressing space or clicking a button.
            Sound could not be played when an event occurred, like a piece
            was taken, or a player was checkmated.
            Therefore, one sound was used for all piece movements, when space was pressed.
        */
        function PlaySound() {
            let path = '/sounds/check.mp3';
            let ele = new Audio(path);
            ele.play();
        }
    </script>
</body>

</html>