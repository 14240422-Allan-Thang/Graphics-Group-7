<html>
<head>
    <title>Chess Project</title>
</head>

<style>
    body {margin: 0;}
    canvas {width: 100%; height: 100%}
</style>

<body>


    <script src="js/three.js"> </script>
    <script src="js/OrbitControls.js"> </script>
    <script src="js/STLLoader.js"></script>

    <style>
        body {
            font-family: Monospace;
            background-color: #000;
            color: #fff;
            margin: 0px;
            overflow: hidden;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
        }
    </style>

    <dic>
        <p>Chess Project</p>
    </dic>

    <script>
        //holds the pieces of each player, whites and blacks
        var black_pieces={};
        var white_pieces={};

        /* StorePGN should write the proper pieces in the array board with the format of "BP0" for black pawn 0 */
        /* 
            B for black, W for white,
            T for tower, H for knight, R for rook, K for king, Q for queen, P for pawn
            0 .. 7 the number of the pieces which are duplicated in each color,
            0 for the ones on the left hand, 1 for the ones on  the right hand, 
        */
        let board = [
          ["BT0", "BH0", "BR0", "BK", "BQ", "BR1", "BH1", "BT1"],
          ["BP0", "BP1", "BP2", "BP3", "BP4", "BP5", "BP6", "BP7"],
          ["", "", "", "", "", "", "", ""],
          ["", "", "", "", "", "", "", ""],
          ["", "", "", "", "", "", "", ""],
          ["", "", "", "", "", "", "", ""],
          ["WP0", "WP1", "WP2", "WP3", "WP4", "WP5", "WP6", "WP7"],
          ["WT0", "WH0", "WR0", "WQ", "WK", "WR1", "WH1", "WT1"]
        ];

        var scene, camera, renderer, group_board;
        var loader = new THREE.STLLoader();
        var material = new THREE.MeshPhongMaterial({ color: 0x55B663 });

        //make the script wait until all the pieces are loaded before initializing the game and rendering
        loadModels().then(
          function(){
            init();
            animate();
          }
        );

        function init() {
            // scene
            scene = new THREE.Scene();
            var container = new THREE.Object3D();

            // renderer
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // camera
            var ratio = window.innerWidth/window.innerHeight;
            camera = new THREE.PerspectiveCamera(45,ratio,0.1,1000);
            camera.position.set(10,10,10); //initial position of the camera

            // resize
            window.addEventListener('resize', function() {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth/ window.innerHeight;
                camera.updateProjectionMatrix();
            });

            // lights
            var light = new THREE.PointLight(new THREE.Color(1,1,1), 1);
            light.position.set(5,5,0)
            scene.add(new THREE.AmbientLight(0x404040));
            scene.add(light);

            //controls
            controls = new THREE.OrbitControls( camera, renderer.domElement );

            //axes. uncomment below line to show axes
            scene.add(new THREE.AxesHelper(20));

            var string = "1. e4 e5 2. Bc4 Nc6 3. Qh5 Nf6 4. Qxf7#";
            var KasparovVsTopalov = "1. e4 e5 2. Bc4 Nc6 3. Qh5 Nf6 4. Qxf7#"

            pgn = StorePGN(string);

            CreateBoard();
            StartGame(pgn);
        }

        function CreateBoard() {
            var tileGeometry = new THREE.BoxGeometry(1, 0.1, 1);
            var blackTileMaterial = new THREE.MeshPhongMaterial ({color: new THREE.Color(0x000000)});
            var whiteTileMaterial = new THREE.MeshPhongMaterial ({color: new THREE.Color(0xffffff)});

            group_board = new THREE.Group();
            
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    var tile; 
                    if (j % 2) {
                      
                      tile = new THREE.Mesh(tileGeometry, i % 2 ? blackTileMaterial : whiteTileMaterial);
                    }
                    else {
                      
                      tile = new THREE.Mesh(tileGeometry, i % 2 ? whiteTileMaterial : blackTileMaterial);
                    }
                    tile.position.set(i, 0, j); 
                    group_board.add(tile); // add the 3d object
                }
            }
            //align the board 3d position to the center of the scene
            group_board.position.x = -(3.5);
            group_board.position.z = -(3.5);
            scene.add(group_board); //adds the group that holds the entire board to the scene
        }

        //variables to keep the models in memory
        var model_pawn = null;
        var model_knight = null;
        var model_rook = null;
        var model_queen = null;
        var model_king = null;
        var model_bishop = null;

        function loadModels(){
          // the loadObject function works asynchronously using callbacks,
          // we use Promise.all to wait for all the models to load before continuing
          return Promise.all(
              [
                loadObject("./models/model_pawn.stl"),
                loadObject("./models/model_knight.stl"),
                loadObject("./models/model_rook.stl"),
                loadObject("./models/model_queen.stl"),
                loadObject("./models/model_king.stl"),
                loadObject("./models/model_bishop.stl")
              ]
          ).then(function(objects){
              model_pawn = objects[0];
              model_knight = objects[1];
              model_rook = objects[2];
              model_queen = objects[3];
              model_king = objects[4];
              model_bishop = objects[5];
          })
        }

        function loadObject(path) {
          // create a new promise that will resolve when the file is completely loaded
          return new Promise(function(resolve,reject){
            loader.load(path, function (geometry) {
              resolve(new THREE.Mesh(geometry, material)); // create a 3d object from the file, and using a placeholder material
             })
          });
        }

        // animation loop
        function animate() {
          controls.update();
          renderer.render(scene, camera);
          requestAnimationFrame(animate);
        }

        function StorePGN(pgn) {
            // "1. e4 Nf6 2. f3 e5" becomes [1., e4, Nf6, 2., f3, e5]
            var moveArray;
            moveArray = pgn.split(/\s+/);
            return moveArray;
        }

        //materials to be reused in the pieces
        var blackPieceMaterial = new THREE.MeshPhongMaterial({ color: new THREE.Color(0x303030) });
        var whitePieceMaterial = new THREE.MeshPhongMaterial({ color: new THREE.Color(0x8f8f8f) });

        function CreatePiece(color, model, name, row, column) {
          // creates a piece cloning the model and set to a position in row, column
          if (color === "W") {
            let pieces = white_pieces; // set to the list of white's pieces
            pieces[name] = model.clone(); 
            pieces[name].material = whitePieceMaterial; 
            pieces[name].position.set(row, 0, column); // assign the position 
            group_board.add(white_pieces[name]); 
          } else if (color === "B") {
            let pieces = black_pieces; // set to the list of black's pieces
            pieces[name] = model.clone(); 
            pieces[name].material = blackPieceMaterial; 
            pieces[name].position.set(row, 0, column); 
            pieces[name].rotation.y = Math.PI; // rotate facing towards whites
            group_board.add(black_pieces[name]); 
          }
        }


        function PlacePieces() {
          // two-loop for assigning each piece in the board
          for (let i = 0; i < 8; i++) {
            for (let j = 0; j < 8; j++) {
              let name = board[i][j]; //  get the piece position from the corresponding cell in the board 2d array
              let color = name.charAt(0); // get the color, W or B
              let piece = name.charAt(1); // get the piece type, P, K, H, T, Q, R
              let number = name.charAt(2); // get the corresponding identifier number

              console.log({ color, piece, number })
              
              switch (piece) {
                case "P":
                CreatePiece(color, model_pawn, name, j, i);
                break;
                case "K":
                CreatePiece(color, model_king, name, j, i);
                break;
                case "H":
                CreatePiece(color, model_knight, name, j, i);
                break;
                case "T":
                CreatePiece(color, model_rook, name, j, i);
                break;
                case "Q":
                CreatePiece(color, model_queen, name, j, i);
                break;
                case "R":
                CreatePiece(color, model_bishop, name, j, i);
                break;
              }
            }
          }
        }

        function StartGame(pgnArray) {
          // this should figure the initial position of the board from the pgnArray String (not implemented)
          // should set up the board array with the proper positions
          for (var i = 0; i < pgnArray.length; i++) {
            // ignore the 1., 2. elements
            var colour = "white";
            if (i % 3 == 0|| i == 0) continue;

            // CheckCommand(pgnArray[i], colour);
            colour = (colour == "white") ? "black": "white";
          }

          // place the pieces according to the board array
          PlacePieces();
        }

        function CheckCommand(command, colour) {
            // Check Contains (+: Check, #: Checkmate, 0-0-0: Castle Queen, 0-0: Castle King, =: Promote pawn, x: takes)
            if (command.includes('+')) {
                // Handle Check
                // Find King
                // Highlight King Tile
                console.log("Check");
            }
            else if (command.includes('#')) {
                // Handle Checkmate
                // Find King
                // Highlight King Tile
                // New Text for checkmate
                console.log("Checkmate");
            }

            if (command.includes("0-0-0")) {
                // Handle Castle Queen
                // Find
                console.log("Queen side Castle");
            }
            else if (command.includes("0-0")) {
                // Handle Castle King
                console.log("King Side Castle");
            }

            if (command.includes('=')) {
                // Handle Promote Pawn
                console.log("Pawn promoted");
            }

            if (command.includes('x')) {
                // Handle Takes
                console.log("Piece Taken");
            }

            var target = LookForPiece(command, colour);
            var destX;
            var destY;
                // do something
            // if doesn't contain, only move piece
            // Check Contains UpperCase (N: Knight, B: Bishop, R:Rook, Q: Queen, K: King)
                // Look for piece
            // if doesn't contain, move pawn
            // if pawn takes empty tile, remove pawn in tile below white/above black
            MovePiece(target, destX, destY);
            return;
        }

        // Change this if you find a better way.
        function LookForPiece(command, colour) {
            if (!command.includes('x')) {
                if (command.includes('N')) {
                    FindKnight(command, colour);
                }
                else if (command.includes('B')) {
                    FindBishop(command, colour);
                }
                else if (command.includes('R')) {
                    FindRook(command, colour);
                }
                else if (command.includes('Q')) {
                    FindQueen(command, colour);
                }
                else if (command.includes('K')) {
                    FindKing(command, colour);
                }
            }
            FindPawn()
        }

        function FindKnight(command, colour) {
            // Find and return the Knight to move
            return;
        }

        function FindBishop(command, colour) {
            // Find and return the Bishop to move
            return;
        }

        function FindRook(command, colour) {
            // Find and return the Rook to move
            return;
        }

        function FindQueen(command, colour) {
            // Find and return the Queen to move
            return;
        }

        function FindKing(command, colour) {
            // Find and return the King to move
            return;
        }

        function FindPawn(command, colour) {
            // Find and return the Pawn to move
            return;
        }

        function MovePiece(target, destinationX, destinationY) {
            // Move a piece, don't need to return anything;
            return;
        }


    </script>
</body>
</html>