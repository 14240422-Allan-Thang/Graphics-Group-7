<html>
<head>
    <title>Chess Project</title>
</head>

<style>
    body {margin: 0;}
    canvas {width: 100%; height: 100%}
</style>

<body>
    <script src="js/three.js"> </script>
    <script src="js/OrbitControls.js"> </script>
    <script src="js/PLYLoader.js"></script>

    <style>
        body {
            font-family: Monospace;
            background-color: #000;
            color: #fff;
            margin: 0px;
            overflow: hidden;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
        }
    </style>

    <dic>
        <p>Chess Project</p>
    </dic>

    <script>
        
        var scene, camera, renderer;
        var board;

        init();
        animate();
        
        function init() {
            
            // scene
            scene = new THREE.Scene();

            // renderer
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            // camera
            var ratio = window.innerWidth/window.innerHeight;
            camera = new THREE.PerspectiveCamera(45,ratio,0.1,1000);
            camera.position.set(0,0,20);
            camera.lookAt(0,0,1);

            // resize
            window.addEventListener('resize', function() {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth, window.innerHeight;
                camera.updateProjectionMatrix();
            });

            // lights
            var light = new THREE.PointLight(new THREE.Color(1,1,1), 0.5);
            camera.add(light);
            scene.add(light);

            // ambient
            
            // geometry
            var plane_geometry = new THREE.PlaneGeometry(10, 10);
            // var plane_material = new THREE.MeshBasicMaterial ({
            //     color: new THREE.Color(0x0000ff),
            //     transparent: false,
            //     opacity: 0.85,
            //     side: THREE.DoubleSide,
            // })
            // plane = new THREE.Mesh(plane_geometry, plane_material);
            // scene.add(plane);

            CreateBoard();
            
            //controls
            controls = new THREE.OrbitControls( camera, renderer.domElement );

            //axes. uncomment below line to show axes
            scene.add(new THREE.AxesHelper(20));
            
            var string = "1. e4 e5 2. Bc4 Nc6 3. Qh5 Nf6 4. Qxf7#";
            var KasparovVsTopalov = "1. e4 e5 2. Bc4 Nc6 3. Qh5 Nf6 4. Qxf7#"
            
            pgn = StorePGN(string);
            
            StartGame(pgn);

        }

        function CreateBoard() {
            var tileGeometry = new THREE.BoxGeometry(1, 0.1, 1);
            var blackTileMaterial = new THREE.MeshBasicMaterial ({color: new THREE.Color(0x000000)});
            var whiteTileMaterial = new THREE.MeshBasicMaterial ({color: new THREE.Color(0xffffff)});

            const Board = {
                tilemap: [],
            };

            board = Board;
            board.tilemap = new Array(8);
            for (let i = 0; i < 8; i++) {
                board.tilemap[i] = new Array(8);
            }

            class Tile {
                constructor(file, rank) {
                    this.file = file;
                    this.rank = rank;
                    this.colour;
                    this.rank;
                    this.file;
                    this.piece;
                    this.mesh;
                }
                getColour() {
                    return this.colour;
                }
                setColour(value) {
                    this.colour = value;
                }
                getRank() {
                    return this.rank;
                }
                setRank(value) {
                    this.rank = value;
                }
                getFile() {
                    return this.file;
                }
                setFile(value) {
                    this.file = value;
                }
                getPiece() {
                    return this.piece;
                }
                setPiece(value) {
                    this.piece = value;
                }
                getMesh() {
                    return this.mesh;
                }
                setMesh(value) {
                    this.mesh = value;
                }
            }

            class Piece {
                constructor(type, tile) {
                    this.type = type;
                    this.tile = tile;
                    this.colour;
                    this.mesh;
                }
                getType() {
                    return this.type;
                }
                getTile() {
                    return this.tile;
                }
                setTile(value) {
                    this.tile = value;
                }
                getColour() {
                    return this.colour;
                }
                setColour(value) {
                    this.colour = value;
                }
                getMesh() {
                    return this.mesh;
                }
                setMesh(value) {
                    this.mesh = value;
                }
            }

            class TakenPieces {
                constructor(colour) {
                    this.colour = colour;
                    this.pieces = [];
                }
                getPieces() {
                    return this.pieces;
                }
                setPieces(value) {
                    this.pieces = value;
                }
                addPiece(value) {
                    this.pieces.push(value);
                }
            }

            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    let tile = new Tile(PosToFile(i), PosToRank(j));
                    var colour;
                    if (j % 2) {
                        colour = (i % 2) ? "black" : "white";
                        tile.setMesh(new THREE.Mesh(tileGeometry, colour.includes("black") ? blackTileMaterial : whiteTileMaterial));
                    }
                    else {
                        colour = (i % 2) ? "white" : "black";
                        tile.setMesh(new THREE.Mesh(tileGeometry, colour.includes("white") ? whiteTileMaterial : blackTileMaterial));
                    }
                    tile.getMesh().position.set(i, 0, j);
                    tile.setColour(colour);
                    board.tilemap[i][j] = tile;
                    scene.add(tile.getMesh());
                }
            }
        }

        function RankToPos(rank) {
            var ranks = ['a','b','c','d','e','f','g','h'];
            return ranks.indexOf(rank);
        }

        function FileToPos(file) {
            return --file;
        }

        function PosToRank(pos) {
            var ranks = ['a','b','c','d','e','f','g','h'];
            return ranks[pos];
        }

        function PosToFile(pos) {
            return ++pos;
        }

        function FindTile(rank, file) {
            return board.tilemap[RankToPos(rank)][FileToPos(file)];
        }

        function AddPiece(pos) {
            // Create piece, add to scene, shoudln't need to return anything.
            return;
        }

        // animation loop
        function animate() {
            renderer.render(scene, camera);
            controls.update();
            requestAnimationFrame(animate);
        }

        function StorePGN(pgn) {
            // "1. e4 Nf6 2. f3 e5" becomes [1., e4, Nf6, 2., f3, e5]
            var moveArray;
            moveArray = pgn.split(/\s+/);
            return moveArray;
        }

        function StartGame(pgnArray) {
            for (var i = 0; i < pgnArray.length; i++) {
                // ignore the 1., 2. elements
                var colour = "white";
                if (i % 3 == 0|| i == 0) continue;

                DoCommand(pgnArray[i], colour);
                colour = (colour.includes("white")) ? "black": "white";
            }
        }

        function DoCommand(command, colour) {
            // Check Contains (+: Check, #: Checkmate, 0-0-0: Castle Queen, 0-0: Castle King, =: Promote pawn, x: takes)
            if (command.includes('+')) {
                // Handle Check
                DoCheck(colour);
                // Remove '+'
                command = command.replace('+', '');
                // Call CheckCommand again
                DoCommand(command, colour);
                // Return so that DoBasicCommand() isn't called twice
                return;
            }
            else if (command.includes('#')) {
                // Handle Checkmate
                DoCheckMate(colour);
                // Remove '#'
                command = command.replace('#', '');
                // Call CheckCommand again
                DoCommand(command, colour);
                // Return
                return;
            }
            
            if (command.includes("0-0-0")) {
                // Handle Castle Queen
                DoCastleQueen(colour);
                // Return
                return;
            }
            else if (command.includes("0-0")) {
                // Handle Castle King
                DoCastleKing(colour);
                // Return
                return;
            }

            if (command.includes('=')) {
                // Handle Promote Pawn
                DoPromotePawn(command, colour);
                // Remove '=' and last char
                command = command.slice(0, command.length - 2);
                // Call CheckCommand again
                DoCommand(command, colour);
                // Return
                return;
            }
            
            if (command.includes('x')) {
                // Handle Takes
                // Remove Piece at pos of last 2 char
                let takenTile = FindTile(command.charAt(command.length - 2), command.charAt(command.length - 1));
                DoTakePiece(colour, takenTile);
                // Remove 'x'
                command = command.replace('x', '');
                // Call CheckCommand again
                DoCommand(command, colour);
                // Return
                return;
            }

            DoBasicCommand(command, colour);
        }

        function DoCheck(colour) {
            return;
            var kingPiece;
            var highlightColour;
            if (colour.includes("white")) {
                // Look for black King tile
                kingPiece = LookForPiece("K", "black");
                let kingTile = kingPiece.tile;
                // Highlight King tile
                kingTile.mesh.colour = highlightColour;
            }
            else {
                // Look for white King
                kingPiece = LookForPiece("K", "white");
                let kingTile = kingPiece.tile;
                // Highlight King tile
                kingTile.mesh.colour = highlightColour;
            }
        }

        function DoCheckMate(colour) {
            DoCheck(colour);
            // new Text to say checkmate;
        }

        function DoCastleQueen(colour) {
            var kingPiece;
            var rookPiece;
            // if white
            if (colour.includes("white")) {
                // Find King
                kingPiece = FindTile('e', 1).piece;
                // Find Rook
                rookPiece = FindTile('a', 1).piece;
                // Move King 2 Left
                MovePiece(kingPiece, 'c', 1);
                // Move Rook 3 Right
                MovePiece(rookPiece, 'd', 1);
            }
            else {
                kingPiece = FindTile('e', 8).piece;
                rookPiece = FindTile('a', 8).piece;
                MovePiece(kingPiece, 'c', 8);
                MovePiece(rookPiece, 'd', 8);
            }
        }
        
        function DoCastleKing(colour) {
            var kingPiece;
            var rookPiece;
            // if white
            if (colour.includes("white")) {
                // Find King
                kingPiece = FindTile('e', 1).piece;
                // Find Rook
                rookPiece = FindTile('h', 1).piece;
                // Move King 2 Right
                MovePiece(kingPiece, 'g', 1);
                // Move Rook 3 Left
                MovePiece(rookPiece, 'f', 1);
            }
            else {
                kingPiece = FindTile('e', 8).piece;
                rookPiece = FindTile('h', 8).piece;
                MovePiece(kingPiece, 'g', 8);
                MovePiece(rookPiece, 'f', 8);
            }
        }

        function DoPromotePawn(command, colour) {
            let newPieceType = command.charAt(command.length - 1);
            var rank;
            if (colour.includes("white")) {
                rank = 7;
            }
            else {
                rank = 2;
            }
            let file = command.charAt(0);
            let pawnTile = FindTile(rank, file);
            // Remove Pawn
            scene.remove(pawnTile.piece.mesh);
            // Add new Piece depending on last letter
            AddPiece(newPieceType, rank, file);
        }

        function DoTakePiece(colour, takenTile) {
            return; // REMOVE THIS WHEN DONE
            // Remove piece at takenTile
            // Move it to TakenPieces of same colour
            takenTile.getPiece().getMesh().position.set(10,0,0);
        }

        function DoBasicCommand(command, colour) {
            // endRank/y-axis = last char
            var endRank = command.charAt(command.length - 1);
            // endFile/x-axis = 2nd last char
            var endFile = command.charAt(command.length - 2);

            // target = piece to move
            var target;

            // if 2 char -- e4
            if (command.length == 2) {
                var tile; 
                // Look for Pawn
                // Set target to Pawn
                if (colour.includes("white")) {
                    target = FindTile(endFile.toString(), (endRank - 1)).piece;
                }
                else {
                    target = FindTile('endFile', (endRank + 1)).piece;
                }
            }
            // if 3 char -- Qe4
            else if (command.length == 3) {
                // Look for piece of type 1st char
                // Type of piece is specified in first char as UpperCase
                var type = command.charAt(0);
                if (IsUpperCase(type)) {
                    target = LookForPiece(type, colour);
                }
                // If type is not UpperCase, type must be pawn and file is specified
                else {
                    target = LookForPiece();
                }
            }
            // if 4 char -- Qde4/Q3e4
            else if (command.length == 4) {
                // Look for piece of type 1st char on 2nd char rank/file
                var disambiguator = command.charAt(1);
                // If 2nd character is a a-h, find piece on that file
                if ((/[a-h]/).test(disambiguator)) {
                    var file = disambiguator;
                }
                // Else 2nd character is 1-8. find piece on that rank
                else {
                    var rank = disambiguator;
                }
                target = LookForPiece();
            }
            // if 5 char -- Qd3e4
            else {
                // Look for piece at position (2nd, 3rd)
                // Move piece to destination
                var targetX = command.charAt(1);
                var targetY = command.charAt(2);
                target = LookForPiece(targetX, targetY)
            }
            
            MovePiece(target, endFile, endRank);
        }

        function IsUpperCase(str) {
            if (str.toUpperCase() === str) return true;
            return false;
        }

        // Change this if you find a better way.
        function LookForPiece(command, colour) {
            if (!command.includes('x')) {
                if (command.includes('N')) {
                    FindKnight(command, colour);
                }
                else if (command.includes('B')) {
                    FindBishop(command, colour);
                }
                else if (command.includes('R')) {
                    FindRook(command, colour);
                }
                else if (command.includes('Q')) {
                    FindQueen(command, colour);
                }
                else if (command.includes('K')) {
                    FindKing(command, colour);
                }
            }
            FindPawn()
        }

        function FindKnight(command, colour) {
            // Find and return the Knight to move
            return;
        }

        function FindBishop(command, colour) {
            // Find and return the Bishop to move
            return;
        }

        function FindRook(command, colour) {
            // Find and return the Rook to move
            return;
        }
        
        function FindQueen(command, colour) {
            // Find and return the Queen to move
            return;
        }

        function FindKing(command, colour) {
            // Find and return the King to move
            return;
        }

        function FindPawn(command, colour) {
            // Find and return the Pawn to move
            return;
        }

        function MovePiece(target, destinationX, destinationY) {
            // Move a piece, don't need to return anything;
            return;
        }

    </script>
</body>
</html>